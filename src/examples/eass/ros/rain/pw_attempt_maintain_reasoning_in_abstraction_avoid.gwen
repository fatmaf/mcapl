EASS
/**
* An attempt at converting a plain gwendolen agent to an EASS agent
**/

// the low level stuff, we want processed quickly
:abstraction: weakener

:Initial Beliefs:
// each location has a coordinate (the belief that this is a location is in the reasoning engine)
//location coordinates
location_coordinate(farwall,7.746,3.835,0.000)
location_coordinate(roomdoor,4.197,0.337,0.004)
location_coordinate(door,-8.180,-3.160,0.000)
location_coordinate(room,1.300,2.200,0.000)
location_coordinate(drumpipes,-4.070,-7.240,0.000)
location_coordinate(tank1face,-0.490,-3.510,0.000)
location_coordinate(stairs,2.940,8.560,0.000)
location_coordinate(tank2face,-0.470,-6.520,0.000)
location_coordinate(pipes,7.790,-2.670,0.000)
location_coordinate(tankset,6.800,-5.690,0.000)
location_coordinate(roomback,4.948,4.055,0.000)
location_coordinate(tank2pipe,5.360,-6.310,0.000)
location_coordinate(tank1,2.300,-1.930,0.000)
location_coordinate(roomwall,-0.557,0.516,0.001)
location_coordinate(corridor,1.870,-0.516,0.000)
location_coordinate(tank2,1.980,-7.880,0.000)
location_coordinate(freezone,-5.970,3.861,0.000)
location_coordinate(drum,-7.250,-5.260,0.000)
location_coordinate(foyer,-7.825,-0.573,0.026)
location_coordinate(tank1pipe,5.480,-3.480,0.000)
location_coordinate(tankzone,-2.198,-4.939,0.000)


//location count for book keeping
// this is used in the abstraction engine so we need to
// TODO: make sure this is assert_shared somewhere!!!
location_count(0)

:Initial Goals:


/* Here is everything that deals with percepts etc from ROS directly */
:Plans:
/* Default plans for handling messages */
+.received(:tell, B): {True} <- +B;
+.received(:perform, G): {True} <- +!G [perform];
+.received(:achieve, G): {True} <- +!G [achieve];

/* just so we know things have started - relevant for the simulation, not sure about actual ROS */
+started: {B location_count(C)} <-
    -location_count(C),
    assert_shared(location_count(C)),
    assert_shared(start),
    +near_percepts_list([]),
    printstate;

// moving
+!move(Loc) [perform]: {B location_coordinate(Loc,X,Y,Z)} <-
    print("AE DEBUG   moving to ",Loc," o",X," ",Y," ",Z,"o "),
    assert_shared(going(Loc)),
    assert_shared(moving),
    move(X,Y,Z);

// the results of ros movebase
+movebase_result(Id,3) : { B moving, B going(Loc) } <-
	print("AE DEBUG   movebase result 3   ","Movement to location ",Loc," ended with success ","movebase id ",Id),
	assert_shared(moved),
	+!move_cleanup[perform];

+movebase_result(Id,3): {~B moving, ~B going(Loc)} <-
    print("AE DEBUG   removing movebase result because no movement"),
     -movebase_result(Id,3);

+movebase_result(Id,0) : { B moving, B going(Loc) } <-
	print("AE DEBUG   movebase result 0   ","moving to ",Loc,"movebase id ",Id,"The goal is pending");

+movebase_result(Id,2) : { B moving, B going(Loc) } <-
	print("AE DEBUG   movebase result 2   ","moving to ",Loc,"movebase id ",Id,"The goal has been cancelled so just clean up"),
	+!move_cleanup[perform];

+movebase_result(Id,1) : { B moving, B going(Loc) } <-
	print("AE DEBUG   movebase result 1   ","moving to ",Loc,"movebase id ",Id,"The goal is being processed");

+movebase_result(Id,4) : { B moving, B going(Loc) } <-
	print("AE DEBUG   ","moving to ",Loc),
    print("AE DEBUG   ","movebase id ",Id),
    print("AE DEBUG   ","The goal has been aborted the robot got stuck so just clean up"),
    +!move_cleanup[perform];

+movebase_result(Id,5) : { B moving, B going(Loc) } <-
    print("AE DEBUG   movebase result 5   ","moving to ",Loc,"movebase id ",Id,"The goal has been rejected bad goal so just clean up"),
    +!move_cleanup[perform];

+movebase_result(Id,6) : { B moving, B going(Loc) } <-
    print("AE DEBUG   movebase result 6   ","moving to ",Loc,"movebase id ",Id,"The goal received a cancel request");

+movebase_result(Id,7) : { B moving, B going(Loc) } <-
    print("AE DEBUG   movebase result 7   ","moving to ",Loc,"movebase id ",Id,"The goal received a cancel request");

+movebase_result(Id,8) : { B moving, B going(Loc) } <-
    print("AE DEBUG   movebase result 8   ","moving to ",Loc,"movebase id ",Id,"The goal has been recalled so just clean up"),
    +!move_cleanup[perform];

// unified clean up
+!move_cleanup[perform]: {B moving, B going(Loc), B cancelled_goal_not_done } <-
    +.lock,
    print("AE DEBUG   move cleanup   "," we did not visit the location because we cancelled the goal in time"),
    remove_shared(cancelled_goal_not_done),
    +!doneMove(Loc)[perform],
    -.lock;

+!move_cleanup[perform]: {B moving, B going(Loc), ~B cancelled_goal_not_done } <-
    +.lock,
    print("AE DEBUG   move clean up    "," will just assume we got there"),
    +!doneMove(Loc)[perform],
    -.lock;


+!move_cleanup[perform]: {~B moving, ~B going(Loc) }
    <- print("AE DEBUG   move clean up   ","move clean up called for no reason");

// what to do when a location has been visited
+!visitedLoc(Loc)[perform] : {B location_count(C), B visited(Loc,Cy)}
//this is different from what I have but I think its fine, well is it? no its not so i'm changing it
        <- print("AE DEBUG   visited loc   ","already visited this location so not adding it");

// do we put this in the abstraction engine or not? for now lets keep it here
+!visitedLoc(Loc)[perform] : {B location_count(C), ~B visited(Loc,C)}
    <-
    assert_shared(visited(Loc,C)), remove_shared(location_count(C)), sum(C,1,NewC), assert_shared(location_count(NewC));

+!visitedLoc(Loc)[perform]: {~B location_count(C), ~B visited(Loc,Cl)}
    <- print("No plan for visited loc because no location count belief ",Loc);

+!visitedLoc(Loc)[perform]: {True} <-
    print("something strange is happening");

// what to do when done moving
+!doneMove(Loc)[perform]: {~B moving} <- do_nothing;

+!doneMove(Loc)[perform]: {B moving, B going(Loc)}
    <-
    remove_shared(going(Loc)),
    print("AE DEBUG   done move   ","done move"),
    remove_shared(moving);

// reached a location
+on(Loc): {B at(Loc)} <- do_nothing;

+on(Loc): {B at(OtherLoc)} <-
    +.lock,
    remove_shared(at(OtherLoc)),
    print("AE DEBUG   at  ","at ",OtherLoc," removed this "," adding at ",Loc),
    assert_shared(at(Loc)),
    +!visitedLoc(Loc)[perform],
    -.lock;

+on(Loc): {~B at(OtherLoc)} <-
    +.lock,
    assert_shared(at(Loc)),
    print("AE DEBUG   at  ","at ",Loc,"  no belief of other loc"),
    +!visitedLoc(Loc)[perform],
    -.lock;


-on(Loc): {True} <- remove_shared(at(Loc)), print("AE DEBUG at   ","removing at ",Loc);

// near a location and we have low radiation
+near(Loc): {B radiation(low), B near_percepts_list([])} <-
    print("AE DEBUG   near loc   ","Near ", Loc," with low radiation"),
    assert_shared(check_violations(Loc)),
    -near_percepts_list([]),
    +near_percepts_list([check_violations(Loc)]);

+near(Loc): {B radiation(low), B near_percepts_list(Nearbeliefs)} <-
    print("AE DEBUG   near loc   ","Near ", Loc," with low radiation adding to percepts list"),
    assert_shared(check_violations(Loc)),
    -near_percepts_list(Nearbeliefs),
    +near_percepts_list([check_violations(Loc) | Nearbeliefs]);

-check_violations(Loc): {B near_percepts_list([])} <- do_nothing;
-check_violations(Loc): {B near_percepts_list([Hbelief|Tbeliefs])} <-
    -near_percepts_list([Hbelief|Tbeliefs]), +near_percepts_list(Tbeliefs);


// near a location and the radiation is not low and we believe we've got some maintain specs
+near(Loc): {~B radiation(low),B radiation(RadVal),B near_percepts_list([])} <-
    print("AE DEBUG   near loc    ","Near ", Loc," with ",RadVal," radiation "),
    assert_shared(check_maintain_violations(near(Loc),radiation(RadVal))),
    -near_percepts_list([]),
    +near_percepts_list([check_maintain_violations(near(Loc),radiation(RadVal))]);

+near(Loc): {~B radiation(low),B radiation(RadVal),B near_percepts_list(Nearbeliefs)} <-
    assert_shared(check_maintain_violations(near(Loc),radiation(RadVal))),
    -near_percepts_list(Nearbeliefs),
    +near_percepts_list([check_maintain_violations(near(Loc),radiation(RadVal)) | Nearbeliefs]);

-check_maintain_violations(near(Loc),radiation(RadVal)): {B near_percepts_list([])} <- do_nothing;
-check_maintain_violations(near(Loc),radiation(RadVal)): {B near_percepts_list([Hbelief|Tbeliefs])} <-
  -near_percepts_list([Hbelief|Tbeliefs]), +near_percepts_list(Tbeliefs);

//// got a radiation percept
+radiation(RadLevel): {True} <-
    print("Radiation level ",RadLevel), +!do_check_maintain_violations[perform],+!printNearBeliefs[perform];
+!do_check_maintain_violations[perform]: {~B radiation(low),B radiation(RadVal), B going(Loc)} <-  print("adding stopping plan belief for rad level ",RadVal," loc ",Loc), assert_shared(stopping_plan), +!stop_moving[perform], assert_shared(check_maintain_violations(near(Loc),radiation(RadVal)));
+!do_check_maintain_violations[perform]: {~B radiation(low),B radiation(RadVal), ~B going(SomeLoc), B near(Loc)} <-  print("adding stopping plan belief for rad level ",RadVal," loc ",Loc), assert_shared(stopping_plan), +!stop_moving[perform],assert_shared(check_maintain_violations(near(Loc),radiation(RadVal)));
+!do_check_maintain_violations[perform]: {B radiation(low)} <- do_nothing;
+!printNearBeliefs[perform]:{B near(Loc)} <- print("Near ",Loc);
+!printNearBeliefs[perform]:{~B near(Loc)} <- print("Not near anything");


+!stop_moving[perform]: {B moving, ~B cancelled_goal, ~B moving_back} <- assert_shared(cancelled_goal_not_done), +!cancel_goal[perform],print("AE DEBUG   send cancel goal   ","Sent goal cancel request");
+!cancel_goal[perform] : {True} <- cancel_goal;

// so here is where all the reasoning is done
// so this is going to be longer
:name: weakener

:Initial Beliefs:
// the set of locations (location coordinates in the abstraction)
//locations
location(farwall)
location(roomdoor)
location(door)
location(room)
location(drumpipes)
location(tank1face)
location(stairs)
location(tank2face)
location(pipes)
location(tankset)
location(roomback)
location(tank2pipe)
location(tank1)
location(roomwall)
location(corridor)
location(tank2)
location(freezone)
location(drum)
location(foyer)
location(tank1pipe)
location(tankzone)




//recording movement
move_history([])
plan_index(0)

//plans
plans([
	plan(visit(tankzone),at(door), 1, [move_to(foyer), move_to(tankzone)]),
	plan(visit(tank2pipe),at(tankzone), 1, [move_to(tank2face),move_to(tank2),move_to(tank2pipe)]),
	plan(visit(tank2pipe),at(tankzone), 2, [move_to(tank1face), move_to(tank1pipe), move_to(tankset),move_to(tank2pipe)]),
	plan(visit(tank2pipe),at(tankzone), 3, [move_to(foyer), move_to(freezone), move_to(stairs),move_to(farwall),move_to(pipes),move_to(tank1pipe),move_to(tankset),move_to(tank2pipe)]),
	plan(visit(tankset),at(tank2pipe),1,[move_to(tankset)]),
	plan(visit(pipes),at(tankset),1,[move_to(pipes)]),
	plan(visit(pipes),at(tank2pipe),1,[move_to(pipes)])
	])
//specs

original_specification("Required",[visit(tankzone),visit(tank2pipe),visit(tankset),visit(pipes),avoid(corridor),maintain(radiation(low))])
original_specification("Preferred",[before(tankzone,tank2pipe),before(tankzone,tankset),before(tankzone,pipes),before(tank2pipe,pipes),before(tankset,pipes),before(tank2pipe,tankset)])


//original_specification("Required",[visit(l4_0), visit(l3_4)])
////,maintain(radiation(low))])
////original_specification("Preferred",[avoid(l2_0),avoid(l2_2),before(l4_0,l4_3)])
//original_specification("Preferred",[maintain(radiation(low)),before(l4_0,l4_3)])

// plan length for bookkeeping
max_plan_len(20)

:Reasoning Rules:

//%//helpers
//%//ismember
ismember(H, [H | T]);
ismember(H, [X | T]) :-
	ismember(H,T);

getindex(H, [H | T],StartingIndex,StartingIndex);
getindex(H, [X | T],StartingIndex,ElementIndex) :-
    next_number(StartingIndex,NextIndex),
	getindex(H,T,NextIndex,ElementIndex);

append([],Ltwo,Ltwo);
append([HLone | Tlone],Ltwo,[HLone | LoneRest]):-
    append(Tlone,Ltwo,LoneRest);


insert_in_list_next_to(LocElem,InsertElem,[],[]);
insert_in_list_next_to(LocElem,InsertElem,[LocElem | T],[LocElem | NewT]):-
    add_to_list(InsertElem,T,NewT);
insert_in_list_next_to(LocElem,InsertElem,[H | T],[H | Rest]):-
    insert_in_list_next_to(LocElem,InsertElem,T,Rest);
// find all the specs in not goals list that
// b or v annots do not satisfy
specs_in_not_goals_not_satisfied([],Vannots,Bannots,[]);

specs_in_not_goals_not_satisfied([avoid(Loc) | T],Vannots,Bannots,[avoid(Loc) | NotSatisfied]):-
    unknown(avoid(Loc)),
    ismember(visit(Loc,Tl),Vannots),
    specs_in_not_goals_not_satisfied(T,Vannots,Bannots,NotSatisfied);

specs_in_not_goals_not_satisfied([avoid(Loc) | T],Vannots,Bannots,NotSatisfied):-
    specs_in_not_goals_not_satisfied(T,Vannots,Bannots,NotSatisfied);

specs_in_not_goals_not_satisfied([before(Bone,Btwo) | T],Vannots,Bannots,[before(Bone,Btwo) |NotSatisfied]):-
    unknown(before(Bone,Btwo)),
    ~ismember(before(Bone,Btwo),Bannots),
    specs_in_not_goals_not_satisfied(T,Vannots,Bannots,NotSatisfied);

specs_in_not_goals_not_satisfied([before(Bone,Btwo) | T],Vannots,Bannots,NotSatisfied):-
    specs_in_not_goals_not_satisfied(T,Vannots,Bannots,NotSatisfied);

specs_in_not_goals_not_satisfied([H|T],Vannots,Bannots,NotSatisfied):-
        specs_in_not_goals_not_satisfied(T,Vannots,Bannots,NotSatisfied);


//%//unique
getunique([],[]);
getunique([H | T],Ul):-
    ismember(H,T),
    getunique(T,Ul);
getunique([H | T], [H | Ul]):-
    getunique(T,Ul);
//%//combine specifications
combined_specifications(CSpecs):-
    specification("Required",RSpec),
    specification("Preferred",PSpec),
    append(RSpec,PSpec,CSpecs);

update_visit_time_from_time(StartTime,TimeIndex,[],[]);
update_visit_time_from_time(StartTime,StartTime,[visit(Loc,StartTime) | Tail],[visit(Loc,NewTimeIndex) | Rest]):-
    next_number(StartTime,NewTimeIndex),
    update_visit_time_from_time(StartTime,NewTimeIndex,Tail,Rest);
update_visit_time_from_time(StartTime,StartTime,[visit(Loc,TimeIndex) | Tail],[visit(Loc,TimeIndex) | Rest]):-
    update_visit_time_from_time(StartTime,StartTime,Tail,Rest);
update_visit_time_from_time(StartTime,TimeIndex,[visit(Loc,TimeIndex)| Tail],[visit(Loc,NewTimeIndex) | Rest]):-
    next_number(TimeIndex,NewTimeIndex),
    update_visit_time_from_time(StartTime,TimeIndex,Tail,Rest);

replace_first_visit_in_visitslist(Loc,TimeIndex,NewTimeIndex,[],[]);
replace_first_visit_in_visitslist(Loc,TimeIndex,NewTimeIndex,[visit(Loc,TimeIndex) | T],[visit(Loc,NewTimeIndex) | T]);
replace_first_visit_in_visitslist(Loc,TimeIndex,NewTimeIndex,[H | T],[H | NewTail]):-
    replace_first_visit_in_visitslist(Loc,TimeIndex,NewTimeIndex,T,NewTail);

replace_first_plan_in_plans(Goal,Source,Index,Actions,Vannots,Bannots,UVannots,UBannots,[],[]);
replace_first_plan_in_plans(Goal,Source,Index,Actions,Vannots,Bannots,UVannots,UBannots,[plan(Goal,Source,Index,Actions,Vannots,Bannots) | T],[plan(Goal,Source,Index,Actions,UVannots,UBannots) | T]);
replace_first_plan_in_plans(Goal,Source,Index,Actions,Vannots,Bannots,UVannots,UBannots,[H | T],[H | Rest]):-
    replace_first_plan_in_plans(Goal,Source,Index,Actions,Vannots,Bannots,UVannots,UBannots,T,Rest);

//%// step 1
//%// strip locs from specs
get_second_location_from_before(before(Lone,Ltwo),Ltwo);
strip_locations_from_specs_wrapper(CSpecs,Locs):-
    strip_locations_from_specs(CSpecs,LocsNotUnique),
    getunique(LocsNotUnique,Locs);

strip_locations_from_spec(visit(Loc),[Loc]);
strip_locations_from_spec(avoid(Loc),[Loc]);
strip_locations_from_spec(before(Bone,Btwo),Blist):-
    append([Bone],[Btwo],Blist);
strip_locations_from_spec(maintain(Property),[]);


strip_locations_from_specs([],[]);
strip_locations_from_specs([H | T],LocsN):-
    strip_locations_from_spec(H,SpecLocs),
    strip_locations_from_specs(T,Locs),
    append(SpecLocs,Locs,LocsN);


// step 2
// annotate plans with visit, before
//we have the list of locations we care about
//if we have a move_to/move to something in our list
//we add the visit annotation

get_visit_annotations(Index,[],Locs,[]);
get_visit_annotations(Index,[move_to(HLoc)|Tactions],Locs,[visit(HLoc,Index) | OtherAnnots]):-
    ismember(HLoc,Locs),
    next_number(Index,NewIndex),
    get_visit_annotations(NewIndex,Tactions,Locs,OtherAnnots);
get_visit_annotations(Index,[move_to(HLoc)|Tactions],Locs, OtherAnnots):-
    next_number(Index,NewIndex),
    get_visit_annotations(NewIndex,Tactions,Locs,OtherAnnots);

get_visit_annotationsInit(at(InitLoc),Actions,Locs,[visit(InitLoc,0) | OtherAnnots]):-
    ismember(InitLoc,Locs),
    get_visit_annotations(1,Actions,Locs,OtherAnnots);

get_visit_annotationsInit(at(InitLoc),Actions,Locs,OtherAnnots):-
    get_visit_annotations(1,Actions,Locs,OtherAnnots);


update_visit_annotations_for_loc(Loc,Actions,OldVisits,[visit(Loc,Index) | OldVisits]):-
    getindex(move_to(Loc),Actions,1,Index);
update_visit_annotations_for_loc(Loc,Actions,OldVisits, OldVisits);

get_loc_index_in_actions(Loc,Actions,ActionIndex):-
    getindex(move_to(Loc),Actions,1,ActionIndex);


get_list_first_elem([H | T],H);
get_list_second_elem([H | T], Second):-
    get_list_first_elem(T,Second);

parse_before(before(BList),B1,B2):-
    get_list_first_elem(BList,B1),
    get_list_second_elem(BList,B2);

// lets go befores from just a list
// so we assume we have a unique list of visits
// with indices
generate_befores_for_plan([],VisitsList,[]);

generate_befores_for_plan([before(Bone,Btwo) | T],VisitsList,PlanBeforesList):-
    visited(Btwo,VBtwo),
    generate_befores_for_plan(T,VisitsList,PlanBeforesList);

generate_befores_for_plan([before(Bone,Btwo) | T],VisitsList,[before(Bone,Btwo) | PlanBeforesList]):-
    visited(Bone,VBone),
    generate_befores_for_plan(T,VisitsList,PlanBeforesList);

generate_befores_for_plan([before(Bone,Btwo) | T],VisitsList,[before(Bone,Btwo) |PlanBeforesList]):-
    ~ismember(visit(Btwo,Pbtwo),VisitsList),
    generate_befores_for_plan(T,VisitsList,PlanBeforesList);

generate_befores_for_plan([before(Bone,Btwo) | T],VisitsList,[before(Bone,Btwo) |PlanBeforesList]):-
    ismember(visit(Btwo,Pbtwo),VisitsList),
    ismember(visit(Bone,Pbone),VisitsList),
    [Pbone < Pbtwo],
    generate_befores_for_plan(T,VisitsList,PlanBeforesList);

generate_befores_for_plan([before(Bone,Btwo) | T],VisitsList,PlanBeforesList):-
    generate_befores_for_plan(T,VisitsList,PlanBeforesList);

//just using the knowledge we have
//generate a befores list from the locations we care about
before_satisfied(Locone,Loctwo):-
    visited(Loctwo,Tltwo),
    visited(Locone,Tlone),
    [Tlone < Tltwo];

before_satisfied(Locone,Loctwo):-
    ~visited(Loctwo,Tltwo),
    visited(Locone,Tlone);

before_violated(Locone,Loctwo):-
    visited(Locone,Tlone),
    visited(Loctwo,Tltwo),
    [Tltwo < Tlone];

before_violated(Locone,Loctwo):-
    ~visited(Locone,Tlone),
    visited(Loctwo,Tltwo);

before_unknown(Locone,Loctwo):-
    ~before_satisfied(Locone,Loctwo),
    ~before_violated(Locone,Loctwo);

avoid_violated(Loc):-
    visited(Loc,Tl);

avoid_unknown(Loc):-
    ~avoid_violated(Loc);

visit_satisfied(Loc):-
    visited(Loc,Tl);

visit_unknown(Loc):-
    ~visit_satisfied(Loc);

unknown(before(Bone,Btwo)):-
    before_unknown(Bone,Btwo);

unknown(avoid(Loc)):-
    avoid_unknown(Loc);

unknown(visit(Loc)):-
    visit_unknown(Loc);

unknown(maintain(Property));

satisfied(before(Bone,Btwo)):-
    before_satisfied(Bone,Btwo);

satisfied(avoid(Loc)):-
    ~visited(Loc, Tl);

satisfied(visit(Loc)):-
    visit_satisfied(Loc);

violated(before(Bone,Btwo)):-
    before_violated(Bone,Btwo);

violated(avoid(Loc)):-
    avoid_violated(Loc);


befores_for_locs(Marker,[],Others,[]);

befores_for_locs(Marker,[HLoc | TLocs],[],OtherBefores):-
    befores_for_locs(first,TLocs, TLocs,OtherBefores);

befores_for_locs(Marker,[HLoc | TLocs],[HLoc | OTLocs],OtherBefores):-
    befores_for_locs(Marker,[HLoc | TLocs], OTLocs,OtherBefores);

befores_for_locs(first,[HLoc | TLocs],[HTLoc | OTLocs],[before(HLoc,HTLoc) | OtherBefores]):-
    befores_for_locs(second,[HLoc | TLocs],[HTLoc | OTLocs],OtherBefores);

befores_for_locs(second,[HLoc | TLocs],[HTLoc | OTLocs],[before(HTLoc,HLoc) | OtherBefores]):-
    befores_for_locs(first,[HLoc | TLocs],OTLocs,OtherBefores);

generate_all_possible_befores_wrapper(Locs,Locs,AllBefores):-
    befores_for_locs(first,Locs,Locs,AllBefores);


generate_befores_from_beliefs([],[],[],[]);
generate_befores_from_beliefs([before(Bone,Btwo) | T],UnknownBefores,[before(Bone,Btwo) | SatisfiedBefores],ViolatedBefores):-
    before_satisfied(Bone,Btwo),
    generate_befores_from_beliefs(T,UnknownBefores,SatisfiedBefores,ViolatedBefores);
generate_befores_from_beliefs([before(Bone,Btwo) | T],UnknownBefores,SatisfiedBefores,[before(Bone,Btwo) | ViolatedBefores]):-
    before_violated(Bone,Btwo),
    generate_befores_from_beliefs(T,UnknownBefores,SatisfiedBefores,ViolatedBefores);

generate_befores_from_beliefs([before(Bone,Btwo) | T],[before(Bone,Btwo)  | UnknownBefores],SatisfiedBefores,ViolatedBefores):-
    generate_befores_from_beliefs(T,UnknownBefores,SatisfiedBefores,ViolatedBefores);

//so for each location, check whether the before has been satisfied, violated or unknown
generate_befores_from_beliefs(Locs,UnknownBefores,SatisfiedBefores,ViolatedBefores,AllPossibleBefores):-
    generate_all_possible_befores_wrapper(Locs,Locs,AllPossibleBefores),
    generate_befores_from_beliefs(AllPossibleBefores,UnknownBefores,SatisfiedBefores,ViolatedBefores);

update_befores_from_beliefs(CurrentlyUnknownBefores,CurrentlySatB,CurrentViolB,UnknownBefores,SatisfiedBefores,ViolatedBefores):-
    generate_befores_from_beliefs(CurrentlyUnknownBefores,UnknownBefores,SatisfiedBeforesN,ViolatedBeforesN),
    append(SatisfiedBeforesN,CurrentlySatB,SatisfiedBefores),
    append(ViolatedBeforesN,CurrentViolB,ViolatedBefores);

get_annotations(UnknownBefores,at(Loc),Actions,Start,Locs,VisitAnnots,BeforesAnnots):-
    get_visit_annotationsInit(at(Loc),Actions,Locs,VisitAnnots),
    generate_befores_for_plan(UnknownBefores,VisitAnnots,BeforesAnnots);


gather_allplan_goals_wrapper(Plans,GoalsList):-
    gather_allplan_goals(Plans,NonUniqueGoalsList),
    getunique(NonUniqueGoalsList,GoalsList);
gather_allplan_goals([],[]);
gather_allplan_goals([plan(Goal,Source,Index,Actions) | TPlans],[Goal | PGoals]):-
    gather_allplan_goals(TPlans,PGoals);


annotate_all_plans(Start,Locs,AllPossibleBefores,[],[]);
annotate_all_plans(Start,Locs,AllPossibleBefores,[plan(Goal,Source,Index,Actions) | TPlans],[plan(Goal,Source,Index,Actions,VisitAnnots,BeforesAnnots) | TUpdatedPlans]):-
    get_annotations(AllPossibleBefores,Source,Actions,Start,Locs,VisitAnnots,BeforesAnnots),
    annotate_all_plans(Start,Locs,AllPossibleBefores,TPlans,TUpdatedPlans);

update_before_annotations([],[]);
update_before_annotations([plan(Goal,at(Loc),Index,Actions,VisitAnnots,OBeforesAnnots) | TPlans],[plan(Goal,at(Loc),Index,Actions,VisitAnnots,BeforesAnnots) | TUpdatedPlans]):-
    generate_befores_for_plan(OBeforesAnnots,VisitAnnots,BeforesAnnots),
    update_before_annotations(TPlans,TUpdatedPlans);

update_visit_annotations(Loc,[],[]);
update_visit_annotations(Loc,[plan(Goal,at(InitLoc),Index,Actions,OVisitAnnots,BeforesAnnots) | TPlans], [plan(Goal,at(InitLoc),Index,Actions,VisitAnnots,BeforesAnnots) | TUpdatedPlans]):-
    update_visit_annotations_for_loc(Loc,Actions,OVisitAnnots,VisitAnnots),
    update_visit_annotations(Loc,TPlans,TUpdatedPlans);

 replace_first_plan_in_plans_revise_for_loc(Loc,Goal,Source,Index,Actions,Vannots,Bannots,UVannots,UBannots,[],[]);
 replace_first_plan_in_plans_revise_for_loc(Loc,Goal,Source,Index,Actions,Vannots,Bannots,UVannots,UBannots,[plan(Goal,Source,Index,Actions,Vannots,Bannots) | T],[plan(Goal,Source,Index,Actions,UVannots,UBannots) | Rest]):-
    replace_first_plan_in_plans_revise_for_loc(Loc,Goal,Source,Index,Actions,Vannots,Bannots,UVannots,UBannots,T,Rest);
 replace_first_plan_in_plans_revise_for_loc(Loc,Goal,Source,Index,Actions,Vannots,Bannots,UVannots,UBannots,[plan(Sgoal,Ssource,Sindex,SActions,Svannots,Sbannots) | T],[plan(Sgoal,Ssource,Sindex,SActions,NSvannots,Sbannots) | Rest]):-
    update_visit_annotations_for_loc(Loc,SActions,Svannots,NSvannots),
     replace_first_plan_in_plans_revise_for_loc(Loc,Goal,Source,Index,Actions,Vannots,Bannots,UVannots,UBannots,T,Rest);
//step 3
//now we've annotated our plans
//so we can select plans we want
//the steps are
//we want to get all plans for our current location
//then we want to filter from these plans
//all plans that have goals that are part of our specification
//so given a list of plans, our specification and the location
//we return a list of "valid plans"
plans_from_loc_with_any_specification(Loc,Specs,[],[]);
plans_from_loc_with_any_specification(Loc,Specs,[plan(Goal,at(Loc),Index,Actions,Vannots,Bannots) | PlanT],[plan(Goal,at(Loc),Index,Actions,Vannots,Bannots) | LPlanT]):-
    unknown(Goal),
    ismember(Goal,Specs),
    plans_from_loc_with_any_specification(Loc,Specs,PlanT,LPlanT);
plans_from_loc_with_any_specification(Loc,Specs,[plan(Goal,at(Loctwo),Index,Actions,Vannots,Bannots) | PlanT], LPlanT):-
    plans_from_loc_with_any_specification(Loc,Specs,PlanT,LPlanT);


subtract_secondlist_from_firstlist([],GoalsList,[]);
subtract_secondlist_from_firstlist([HSpec | TSpec],GoalsList,NotGoalsList):-
    ismember(HSpec,GoalsList),
    subtract_secondlist_from_firstlist(TSpec,GoalsList,NotGoalsList);
subtract_secondlist_from_firstlist([HSpec | TSpec],GoalsList,[HSpec | NotGoalsList]):-
    subtract_secondlist_from_firstlist(TSpec,GoalsList,NotGoalsList);


plan_exists(Goal,Source,Index,Actions,Vannots,Bannots):-
    plans(Plans),
    plan_exists(Plans,Goal,Source,Index,Actions,Vannots,Bannots);

plan_exists([plan(Goal,Source,Index,Actions,Vannots,Bannots) | T],Goal,Source,Index,Actions,Vannots,Bannots);
plan_exists([H | T],Goal,Source,Index,Actions,Vannots,Bannots):-
    plan_exists(T,Goal,Source,Index,Actions,Vannots,Bannots);


get_plans_for_spec(S,[],[]);
// avoid is the absence of a visit
// so if you see visit loc then you dont add it
get_plans_for_spec(maintain(Property),Plans,Plans);
get_plans_for_spec(avoid(Loc), [plan(Goal,Source,Ind,Actions,Vannots,Bannots) | TP], Res) :-
	ismember(visit(Loc,Tl),Vannots),
	get_plans_for_spec(avoid(Loc),TP,Res);
//if you dont see visit loc then you can add it
get_plans_for_spec(avoid(Loc),[plan(Goal,Source,Ind,Actions,Vannots,Bannots) | TP], [plan(Goal,Source,Ind,Actions,Vannots,Bannots) | Res]):-
	get_plans_for_spec(avoid(Loc),TP,Res);
//visit is self-explanatory
//see it , add it
get_plans_for_spec(visit(Loc),[plan(Goal,Source,Ind,Actions,Vannots,Bannots) | TP], [plan(Goal,Source,Ind,Actions,Vannots,Bannots) | Res] ):-
    ismember(visit(Loc,Tl),Vannots),
    get_plans_for_spec(visit(Loc),TP,Res);
//dont see it
//dont add it
get_plans_for_spec(visit(Loc),[plan(Goal,Source,Ind,Actions,Vannots,Bannots) | TP], Res):-
	get_plans_for_spec(visit(Loc),TP,Res);

//before is self-explanatory
//see it , add it
get_plans_for_spec(before(Bone,Btwo),[plan(Goal,Source,Ind,Actions,Vannots,Bannots) | TP], [plan(Goal,Source,Ind,Actions,Vannots,Bannots) | Res] ):-
    ismember(before(Bone,Btwo),Bannots),
    get_plans_for_spec(before(Bone,Btwo),TP,Res);
//dont see it
//dont add it
get_plans_for_spec(before(Bone,Btwo),[plan(Goal,Source,Ind,Actions,Vannots,Bannots) | TP], Res):-
	get_plans_for_spec(before(Bone,Btwo),TP,Res);


// now from these plans we want to find valid plans
find_valid_plans(NotGoalsList,Preferred,Plans,PossiblePlans):-
    append(NotGoalsList,Preferred,SpecsForPlans),
    find_valid_plans(SpecsForPlans,Plans,PossiblePlans);

//getting plans with weakening
find_valid_plans([],Plans,Plans);
find_valid_plans([H|T],Plans,PossiblePlans):-
    unknown(H),
	get_plans_for_spec(H,Plans,PlanSet),
	check_plans_for_spec(Plans,PlanSet,NewPlanSet),
	find_valid_plans(T,NewPlanSet,PossiblePlans);

find_valid_plans([H|T],Plans,PossiblePlans):-
	find_valid_plans(T,Plans,PossiblePlans);

check_plans_for_spec(L,[],L);
check_plans_for_spec(L,NL,NL);

get_first_plan([plan(Goal,Source,Index,Actions,Vannots,Bannots) | Rest],plan(Goal,Source,Index,Actions,Vannots,Bannots));

// what do I do for maintains
// if its a maintain, I just ignore it

specs_unknown_satisfied_violated([],[],[],[]);
specs_unknown_satisfied_violated([visit(Loc)|T],UnknownR,[visit(Loc) | SatisfiedR],ViolatedR):-
    visited(Loc,Tl),
    specs_unknown_satisfied_violated(T,UnknownR,SatisfiedR,ViolatedR);
specs_unknown_satisfied_violated([before(Bone,Btwo)|T],UnknownR,[before(Bone,Btwo) | SatisfiedR],ViolatedR):-
    satisfied(before(Bone,Btwo)),
    specs_unknown_satisfied_violated(T,UnknownR,SatisfiedR,ViolatedR);
specs_unknown_satisfied_violated([before(Bone,Btwo) |T],UnknownR,SatisfiedR,[before(Bone,Btwo) | ViolatedR]):-
    violated(before(Bone,Btwo)),
    specs_unknown_satisfied_violated(T,UnknownR,SatisfiedR,ViolatedR);
specs_unknown_satisfied_violated([avoid(Loc) |T],UnknownR,SatisfiedR,[avoid(Loc) | ViolatedR]):-
    avoid_violated(Loc),
    specs_unknown_satisfied_violated(T,UnknownR,SatisfiedR,ViolatedR);
specs_unknown_satisfied_violated([H|T],[H | UnknownR],SatisfiedR,ViolatedR):-
    unknown(H),
    specs_unknown_satisfied_violated(T,UnknownR,SatisfiedR,ViolatedR);


// given a list of specs, and a percept we want to see if we could violate any of these specs
// can_violate(Near(Percept),Specs,CouldViolate)
// if its a before([l1,l2]) we can violate if percept is l2 and we have not visited l1
// if its an avoid(l1) we can violate if l1 = percept
// if its a visit we cant really violate it so we cool so far
can_violate(near(Loc),[],[]);
can_violate(near(Btwo),[before(Bone,Btwo) | TSpecs],[before(Bone,Btwo) | Rest]):-
//    parse_before(before(Blist),Bone,Loc),
    ~visited(Bone,Tb),
    can_violate(near(Btwo),TSpecs,Rest);

can_violate(near(Btwo),[before(Bone,Btwo) | TSpecs], Rest):-
    can_violate(near(Btwo),TSpecs,Rest);

can_violate(near(Loc),[avoid(Loc) | TSpecs], [avoid(Loc) | Rest]):-
    can_violate(near(Loc),TSpecs,Rest);

can_violate(near(Loc),[H | T],Rest):-
    can_violate(near(Loc),T,Rest);


// to revise your annotations you need the ones it can violate
// we can only violate a before or an avoid
// if its an avoid, we add a visit to our list
// if its a before, we are basically visiting l2 before l1, so we need to add a visit too
// and then just repeat the before annots for this plan
// and then just update our plans

revise_annotations(Loc,near(NextLoc),CurrentPlanIndex,Vannots,Bannots,[visit(NextLoc,NextLocIndex) | UpdatedVannots],UpdatedBannots):-
// insert nextloc at current plan index
    next_number(CurrentPlanIndex,IncrementedIndex),
    update_visit_time_from_time(IncrementedIndex,IncrementedIndex,Vannots,UpdatedVannots),
    next_number(CurrentPlanIndex,NextLocIndex),
    generate_befores_for_plan(Bannots,[visit(NextLoc,NextLocIndex) | UpdatedVannots],UpdatedBannots);


replace_plan_annots_in_plans(Plans,Goal,Source,Index,Actions,UVannots,UBannots,NewPlans):-
    replace_first_plan_in_plans(Goal,Source,Index,Actions,Vannots,Bannots,UVannots,UBannots,Plans,NewPlans);

replace_plan_annots_in_plans_revise_for_loc(Loc,Plans,Goal,Source,Index,Actions,UVannots,UBannots,NewPlans):-
    replace_first_plan_in_plans_revise_for_loc(Loc,Goal,Source,Index,Actions,Vannots,Bannots,UVannots,UBannots,Plans,NewPlans);


add_to_list(InsertElem,Oldlist,[InsertElem | Oldlist]);


list_has_no_visits([],[]);
list_has_no_visits([visit(Loc) | Tail],[visit(Loc) | OtherTail]):-
    list_has_no_visits(Tail,OtherTail);
list_has_no_visits([H | Tail],OtherTail):- list_has_no_visits(Tail,OtherTail);

speclist_has_maintain([],[]);
speclist_has_maintain([maintain(Property) | T],[maintain(Property) | Rest]):-
    speclist_has_maintain(T,Rest);
speclist_has_maintain([H | T], Rest):-
    speclist_has_maintain(T,Rest);


:Initial Goals:



:Plans:

+start: {True} <- print("Recieved start belief"), +!initial_setup[perform];
//******************************************//
// helper beliefs are
// increments
// specification - req, pref, [req,not goals], [befores, sat], [befores, viol], [befores, unknown]
// locations of interest
+!add_helper_beliefs[perform]: {B plans(Plans)} <-
                            +!generate_inc_beliefs(0)[perform],
                            +!do_all_spec_beliefs[perform],
                            +!print_specification_beliefs("add helper beliefs   ")[perform],
                            +!print_not_goals("add helper beliefs   ")[perform];

// INCREMENTS - because I cant add in gwendolen
+!generate_inc_beliefs(Index)[perform] : {B plans(Plans), B max_plan_len(Index)} <- do_nothing;
+!generate_inc_beliefs(Index)[perform] : {B plans(Plans), B max_plan_len(Len)} <-
                    sum(Index,1,Index1),
                    +next_number(Index,Index1),
                     +!generate_inc_beliefs(Index1)[perform];


+!print_inc_belief(Index)[perform] : {B plans(Plans), B max_plan_len(Index)} <- do_nothing;
+!print_inc_belief(Index)[perform]: {B plans(Plans),
B next_number(Index,Index1), ~B max_plan_len(Index)}
<- print("RE DEBUG   ","Print next number   ","Next number"),
print("RE DEBUG   ","Print next number   ",Index),print("RE DEBUG   ","Print next number   ",Index1),+!print_inc_belief(Index1)[perform];

// SPECIFICATIONS
// required and preferred
+!add_specifications[perform]:  {
                                B plans(Plans),
                                 B original_specification("Required",Rspec),
                                 B original_specification("Preferred",Pspec)
                                 } <-
                                +specification("Required",Rspec),+specification("Preferred",Pspec);
+!add_not_goals_spec[perform]: { B plans(Plans),
                                B gather_allplan_goals_wrapper(Plans,GoalsList),
                                B specification("Required",Rspec),
                                B subtract_secondlist_from_firstlist(Rspec,GoalsList,NotGoalsList),
                                B specification("Combined",Cspecs)
                                ,
                                B subtract_secondlist_from_firstlist(Cspecs,GoalsList,AllNotGoalsList)
                                }
                                <-
                                print("RE DEBUG   add not goals spec   Plans   ",Plans),
                                print("RE DEBUG   add not goals spec   GoalsList   ",GoalsList),
                                +specification("Not goals",AllNotGoalsList),
                                +specification("Goals",GoalsList),
                                +specification("Required","not goals",NotGoalsList)
                                ;
+!all_req_visits_have_plans[perform] : {B plans(Plans),
B specification("Required","not goals",NotGoalsList),
                            B list_has_no_visits(NotGoalsList,Missing)} <- print("RE DEBUG   all req visits have plans   ",Missing),+!req_visits_is_empty(Missing)[perform];
+!req_visits_is_empty([])[perform] : {True} <- print("All visits in required have plans"), +req_visits_have_plans;
+!req_visits_is_empty(Missing)[perform] : {True} <- print("Some visits in required do not have plans ",Missing);
+!add_locations_of_interest[perform]:
                                      {B combined_specifications(CSpecs)
                                      ,
                                       B strip_locations_from_specs_wrapper(CSpecs,Locs)
                                       }
                                       <-
                                       +locations_of_interest(Locs),
                                       +specification("Combined",CSpecs)
                                       ;
+!check_for_maintains[perform]: {B plans(Plans),
B specification("Combined",CSpecs), B speclist_has_maintain(CSpecs,MSpecs)} <-
print("RE DEBUG   check for maintains   ",MSpecs), +!generate_maintain_belief(MSpecs)[perform];
+!generate_maintain_belief([])[perform]: {B plans(Plans)} <- print("RE DEBUG   generate maintain belief   No maintain belief added since no maintain properties");
+!generate_maintain_belief(MSpecs)[perform]: {B plans(Plans)} <- +specification("Maintain",MSpecs),
                                    print("RE DEBUG   generate maintain belief   maintain belief added");
//update specs
 +!update_specs_with_avoid_loc(MaintainSpec,Loc)[perform]: {B plans(Plans)} <- +.lock,
 +!update_req_pref_specs_with_avoid_loc(MaintainSpec,Loc)[perform],   +!update_combined_specs[perform], +!update_locs_of_interest(Loc)[perform],                                             +!print_specification_beliefs("update required preferences with ")[perform],
                        -.lock;
 +!update_req_pref_specs_with_avoid_loc(MaintainSpec,Loc)[perform]: {B plans(Plans),
 B specification("Required",Rspec),
                                                B specification("Preferred",Pspec),
                                                B specification("Required","not goals",Rngspec),
                                                B insert_in_list_next_to(MaintainSpec,avoid(Loc),Pspec,Npspec),
                                                B insert_in_list_next_to(MaintainSpec,avoid(Loc),Rspec,Nrspec),
                                                B insert_in_list_next_to(MaintainSpec,avoid(Loc),Rngspec,Nrngspec)
                                                } <- -specification("Required",Rspec),
                                                 -specification("Preferred",Pspec),
                                                 -specification("Required","not goals",Rngspec),
                                                 +specification("Required",Nrspec),
                                                 +specification("Preferred",Npspec),
                                                 +specification("Required","not goals",Nrngspec);
+!update_combined_specs[perform]: {B plans(Plans),
B specification("Combined",Oldspecs),
                                B combined_specifications(CSpecs)} <- -specification("Combined",Oldspecs),
                                +specification("Combined",CSpecs);
+!update_locs_of_interest(Loc)[perform]: {B plans(Plans),
B locations_of_interest(OldLocs),
                                B add_to_list(Loc,OldLocs,NewLocs)} <- -locations_of_interest(OldLocs), +locations_of_interest(NewLocs);

+!do_all_spec_beliefs[perform] : {B plans(Plans)} <- +.lock,
//                                            +!print_specification_beliefs[perform],
                                            +!add_specifications[perform],
//                                             +!print_specification_beliefs("do all spec beliefs   ")[perform],
                                             +!add_locations_of_interest[perform],
                                             +!print_specification_beliefs("do all spec beliefs   ")[perform],
//                                                    +!print_specification_beliefs[perform],
                                            +!add_not_goals_spec[perform],
                                                                                        +!check_for_maintains[perform],

                                            +!print_specification_beliefs("do all spec beliefs   ")[perform],
                                             +!generate_befores[perform],
                                             -.lock;
+!print_specification_beliefs(CallingAction)[perform]: {B plans(Plans)} <- +!print_specification_belief(CallingAction,"Required")[perform],
                                    +!print_specification_belief(CallingAction,"Preferred")[perform],
                                    +!print_specification_belief(CallingAction,"Combined")[perform],
                                    +!print_specification_belief(CallingAction,"Goals")[perform],
                                    +!print_specification_belief(CallingAction,"Maintain")[perform];

+!print_not_goals(CallingAction)[perform]: {B plans(Plans),
B specification("Required","not goals",Ng), B locations_of_interest(Locs)}
 <- print("RE DEBUG  ",CallingAction,"Print not goals   ","Req not goals",Ng), print("RE DEBUG  ",CallingAction,"Print not goals   ","Locs of interest",Locs);

+!print_specification_belief(CallingAction,SName)[perform]: {B plans(Plans),
B specification(SName,Spec)} <- print("RE DEBUG  ",CallingAction,"Print spec belief   ",SName," ",Spec);
+!print_specification_belief(CallingAction,SName)[perform]: {B plans(Plans),
~B specification(SName,Spec)} <- print("RE DEBUG  ",CallingAction,"Print spec belief   ",SName," does not exist");
// Generating befores
+!generate_befores[perform]: {B plans(Plans),
B locations_of_interest(Locs),
                              B generate_befores_from_beliefs(Locs,UnknownBefores,SatisfiedBefores,ViolatedBefores,AllPossibleBefores)  }
                              <- +specification("befores","unknown",UnknownBefores),
                              +specification("befores","satisfied",SatisfiedBefores),
                              +specification("befores","violated",ViolatedBefores),
                              print("RE DEBUG  ","generate befores   ","Befores u",UnknownBefores),
                              print("RE DEBUG  ","generate befores   ","Befores s",SatisfiedBefores),
                              print("RE DEBUG  ","generate befores   ","Befores v",ViolatedBefores),
                              print("RE DEBUG  ","generate befores   ","All possible befores",AllPossibleBefores);

/**************************************************************/
// annotating plans
+!add_plan_annotations_action[perform]: {
                                    ~B initial_setup_complete,
                                   B locations_of_interest(Locs),
                                  B specification("befores","unknown",UnknownBefores),
                                  B plans(Plans)
                                  ,B annotate_all_plans(1,Locs,UnknownBefores,Plans,AnnotatedPlans)
                                  }
                                  <-

                                  print("RE DEBUG   ","add plan annotations   ","Old plans",Plans),
                                  print("RE DEBUG   ","add plan annotations   ","Annotated plans",AnnotatedPlans),
                                   +.lock,
                                              -plans(Plans),
                                  +plans(AnnotatedPlans),

                                                                    assert_shared(initial_setup_complete),
                                                                                                       					+!get_specifications_status[perform],
 -.lock
;
+!add_plan_annotations_action[perform]: {B plans(Plans),
B initial_setup_complete} <- +.lock, +!update_before_beliefs[perform], +!update_before_annotations_action[perform], -.lock
                                   					,+!get_specifications_status[perform];
 +!update_before_beliefs[perform]: {B specification("befores","unknown",UB),
                                          B specification("befores","satisfied",SB)
                                           ,B specification("befores","violated",VB)
                                           ,B update_befores_from_beliefs(UB,SB,VB,NUb,NSb,NVb)
                                           }
                                           <-
                                           -specification("befores","unknown",UB)
                                           ,-specification("befores","satisfied",SB)
                                           ,-specification("befores","violated",VB)
                                           ,+specification("befores","unknown",NUb)
                                           ,+specification("befores","satisfied",NSb)
                                           ,+specification("befores","violated",NVb);
+!update_visit_annotations_for_loc_action(Loc)[perform]:
                        { B plans(Plans), B initial_setup_complete
                        , B update_visit_annotations(Loc,Plans,UpdatedPlans)
                            }         <-       print("RE DEBUG   ","Update visit annots for loc   "," Old plans",Plans),
                                       print("RE DEBUG   ","Update visit annots for loc   "," Loc ",Loc)
                                       , print("RE DEBUG   ","Update visit annots for loc   "," Updated plans",UpdatedPlans)
;

+!update_before_annotations_action[perform]: {
          B plans(Plans)
          ,B initial_setup_complete
           ,B update_before_annotations(Plans,UpdatedPlans)}
           <-
           print("RE DEBUG   ","update before annotations   ","Old plans",Plans),
           print("RE DEBUG   ","update before annotations   ","Updated plans ",UpdatedPlans),
           +.lock,
            -plans(Plans),
                                                                              +plans(UpdatedPlans),
                                                                              -.lock;

/**************************************/
// so now we've got plans annotated.
// the next thing we need to do is
// choose a plan
+!get_available_plans[perform]: {B plans(Plans),
                        ~B at(Loc)} <- print("RE DEBUG   get available plans   I am nowhere"),
            +!get_available_plans[perform];
+!get_available_plans[perform]: {B at(Loc)
                                ,B specification("Combined",Specs)
                                ,B plans(Plans)
                                ,B plans_from_loc_with_any_specification(Loc,Specs,Plans,AvailablePlans)}
                                <-
                                print("RE DEBUG   get available plans   ","at ",Loc),
                                print("RE DEBUG   get available plans   ","Combined specs ",Specs),
                                print("RE DEBUG   get available plans   ","Plans",Plans),
                                print("RE DEBUG   get available plans   ","Available plans",AvailablePlans),
                                +!find_valid_plans_action(AvailablePlans)[perform];
+!get_available_plans[perform]: {~B plans(Plans)} <- print("RE DEBUG   "," no plans retrying") ;
+!get_available_plans[perform]: {B plans(Plans)} <- print("RE DEBUG   "," something else is missing");
+!print_specification_status[perform]: {B plans(Plans),
                                    B specification("Combined",Specs),
                                    B specs_unknown_satisfied_violated(Specs,USpecs,SSpecs,VSpecs)
                                        }   <-
                                        print("RE DEBUG   print spec status   ","Unknown specs",USpecs),
                                        print("RE DEBUG   print spec status   ","Satisfied specs",SSpecs),
                                        print("RE DEBUG   print spec status   ","Violated specs",VSpecs);

+!get_specifications_status[perform]: {B plans(Plans),
                            B specification("Combined",Specs),
                            B specs_unknown_satisfied_violated(Specs,USpecs,SSpecs,VSpecs)
                            ,B specification("Unknown",PrevUSpecs)
                            } <-
                            -specification("Unknown",PrevUSpecs),
                            +specification("Unknown",USpecs),
                            print("RE DEBUG   get spec status   ","Unknown specs",USpecs)
                            ,print("RE DEBUG   get spec status   ","Satisfied specs",SSpecs)
                            ,print("RE DEBUG   get spec status   ","Violated specs",VSpecs)
                            ,+!do_plans(USpecs)[perform]
                            ;
+!get_specifications_status[perform]: {B plans(Plans),
B specification("Combined",Specs),
                            B specs_unknown_satisfied_violated(Specs,USpecs,SSpecs,VSpecs)
                            ,~B specification("Unknown",PrevUSpecs)
                            } <-

                            +specification("Unknown",USpecs),
                            print("RE DEBUG   get spec status   ","Unknown specs",USpecs)
                            ,print("RE DEBUG   get spec status   ","Satisfied specs",SSpecs)
                            ,print("RE DEBUG   get spec status   ","Violated specs",VSpecs)
                            ,+!do_plans(USpecs)[perform]
                            ;
+!get_specifications_status[perform]: {~B plans(Plans)} <- print("RE DEBUG  get spec status   ","no plans");
+!do_plans([])[perform] : {B plans(Plans)} <- print("RE DEBUG   do plans   ","I received an empty list of specs so we are all done");
+!do_plans(USpecs)[perform]:{B plans(Plans)} <- print("RE DEBUG   do plans   ","I received the following",USpecs),
                            +!get_available_plans[perform];
+!find_valid_plans_action(AvailablePlans)[perform]: {
B plans(Plans),
                                B specification("Required","not goals",Ng)
                                ,B specification("Preferred",Pspec)
                                ,B find_valid_plans(Ng,Pspec,AvailablePlans,ValidPlans)
                             }
                             <-
                             print("RE DEBUG   find valid plans   ","Finding plans for ",Ng,Pspec)
//                             ,
//                             +!print_specification_beliefs[perform]
//                             ,+!print_not_goals[perform]
                             ,print("RE DEBUG   find valid plans   ","Valid plans",ValidPlans),
                             +!choose_first_plan(ValidPlans)[perform]
                             ;

// once you have valid plans you
// choose a plan and add all the annotations from that plan
// that you care about i.e. the ones in your specifications
// to a possible violations list
+!choose_first_plan([])[perform]: {B plans(Plans)} <- print("RE DEBUG   choose first plan   ","No valid plans so we are all done"), +no_valid_plans, +!print_specification_status[perform];
+at(Loc):{B no_valid_plans} <- print("RE DEBUG   ","at ",Loc,"  I seem to have moved so will attempt to find new plans"), -no_valid_plans, +!get_new_plan[perform];

+!choose_first_plan(ValidPlans)[perform]: {B plans(Plans),
        B get_first_plan(ValidPlans,plan(Goal,Source,Index,Actions,Vannots,Bannots))
                ,B specification("Not goals",AllNotGoalsList)
                ,B specs_in_not_goals_not_satisfied(AllNotGoalsList,Vannots,Bannots,PossibleViolations)
                ,B specification("Unknown",USpecs)
                ,B subtract_secondlist_from_firstlist(USpecs,PossibleViolations,CanViolate)

            }
            <-
            print("RE DEBUG   choose first plan   ","Unknown specs  ",USpecs),
            print("RE DEBUG   choose first plan   ","Selecting plan")
            ,+!printPlan(Goal,Source,Index,Actions,Vannots,Bannots)[perform]

            ,+possible_violations(PossibleViolations)
            ,+specification("Can violate",CanViolate)

            ,print("RE DEBUG   choose first plan   ","Possible plan violations",PossibleViolations)
            ,print("RE DEBUG   choose first plan   ","can violate ",CanViolate)
            ,+!do_all_plan_steps(Goal,Source,Index)[achieve]
            ;


+!get_new_plan[perform]: {B plans(Plans)} <-      +!drop_can_violate_belief[perform]
                                   					;
// to stop a plan
// you need to drop the achieve goal

+!stop_plan[achieve]:{B current_plan(Goal,Source,Index,Actions),
                             ~B moving,
                             ~B moving_back,
                             B cancelled_goal,
                             B plans(Plans)
                            }
                            <-
                            +.lock,
                            assert_shared(moving_back),
                            +stop_plan,
                            print("RE DEBUG   stop plan   ","Dropping current plan ",Goal,Index),
                            -current_plan(Goal,Source,Index,Actions),
                            print("RE DEBUG   stop plan   ","Dropping achieve goal too"),
                            -!do_all_plan_steps(Goal,Source,Index)[achieve],
                            +!move_back[achieve],
                            -.lock;

+!stop_plan[achieve]: {B plans(Plans),
B current_plan(Goal,Source,Index,Actions),
                    ~B moving, ~B moving_back, ~B cancelled_goal}
                    <-
                    assert_shared(moving_back),
                    +stop_plan,
                    print("RE DEBUG   stop plan   ","Stopping plan not moving"),
                    -!do_all_plan_steps(Goal,Source,Index)[achieve],
                    -current_plan(Goal,Source,Index,Actions),
                    +!move_back[achieve];
+!stop_plan[achieve]: {B plans(Plans),
~B current_plan(Goal,Source,Index,Actions),
                        ~B moving_back, ~B moving, ~B cancelled_goal}
                        <- assert_shared(moving_back), +stop_plan, print("RE DEBUG   stop plan   ","Stopping plan with no current plan"), +!move_back[achieve];

+!stop_plan[achieve]: {B plans(Plans),
 B current_plan(Goal,Source,Index,Actions) ,
                        B moving,
                        ~B moving_back,
                        ~B cancelled_goal}<-
                        +!send_cancel_goal[perform];

+!stop_plan[achieve]: {B plans(Plans),
B current_plan(Goal,Source,Index,Actions), ~B moving, ~B moving_back,B cancelled_goal} <- do_nothing;
+!stop_plan[achieve]: {B plans(Plans),
B moving_back, B moving} <- do_nothing;
+!stop_plan[achieve]:{B plans(Plans)} <-  do_nothing;

+!stop_plan[achieve]:{~B plans(Plans)}<- do_nothing;

+!send_cancel_goal[perform]: {B plans(Plans),
B moving} <- +.lock, perf(cancel_goal),
+cancelled_goal, assert_shared(cancelled_goal_not_done), print("RE DEBUG   send cancel goal   ","Sent goal cancel request"), -.lock;

// send a stop moving signal
// once youve stopped moving
// you move back
+!move_back[achieve]:{B plans(Plans),
B move_history([FAct|TActs]),
					  ~B move_back_list(MBL)
					  ,~B moving}
					  <-
					  print("RE DEBUG   move back   ","Moving back for the first time"),
					  +move_back_list([FAct|TActs]),
					  +!doMoveBackActions[perform];



+!move_back[achieve]:{B plans(Plans),
B move_back_list([]), ~B moving
					  }
					  <-
					  +.lock,
					  print("RE DEBUG   move back   ","Moved back"),
					  -move_back_list([]),
					  +move_back,
					  -cancelled_goal,
					  remove_shared(moving_back),
					  -violation_detected,
					  print("removing stopping plan belief"),
					  remove_shared(stopping_plan),
					  +!get_new_plan[perform],
					  -.lock
					  ;

+!move_back[achieve]:{B plans(Plans),
B move_back_list([FAct|TActs]), ~B moving
					  }
					  <-  print("RE DEBUG   move back   ","Doing moveback actions"),+!doMoveBackActions[perform];
+!move_back[achieve]: {B plans(Plans),
B moving} <- do_nothing;
+!doMoveBackActions[perform]: {B plans(Plans),
B move_back_list([FAct|TActs]) }
					<-
					print("RE DEBUG   move back   ","Moving back ",FAct),
					+!doAction(FAct)[perform],
					-move_back_list([FAct|TActs]),
					+move_back_list(TActs)
					;
// then you can find a new plan
+!drop_can_violate_belief[perform]: {B plans(Plans),
B specification("Can violate",CanViolate)} <-
print("RE DEBUG   drop can violate belief   ","Dropping can violate ",CanViolate), -specification("Can violate",CanViolate),
+!drop_possible_violations[perform];
+!drop_can_violate_belief[perform]: {B plans(Plans),
~B specification("Can violate",CanViolate)} <- print("RE DEBUG   drop can violate belief   ","No can violate specification belief"),
                                                       +!drop_possible_violations[perform];

+!drop_possible_violations[perform]: {B plans(Plans),B possible_violations(OldVs) } <-
                print("RE DEBUG   drop possible violations   ","Dropping old plans possible violations",OldVs),
                -possible_violations(OldVs), +!add_plan_annotations_action[perform];
+!drop_possible_violations[perform]: {B plans(Plans),~B possible_violations(OldVs) } <-
print("RE DEBUG   drop possible violations   ","No belief about possible violations"),+!add_plan_annotations_action[perform];


// then you set about achieving the plan
+!do_all_plan_steps(Goal,Source,Index)[achieve]: {B plans(Plans),
B moving} <- /*print("RE DEBUG   achieve plan   ","moving"),*/do_nothing;

+!do_all_plan_steps(Goal,Source,Index)[achieve]: {B plans(Plans),
B current_plan(Goal,Source,Index,[]),
                                        ~B moving,
                                        ~B moving_back} /*done*/
									<-
					print("RE DEBUG   achieve plan   ","Empty plan actions so all done ",Goal,Index),
					+!printCurrentPlanBelief[perform],
					+do_all_plan_steps(Goal,Source,Index),
					print("RE DEBUG   achieve plan   ","Removed belief of current plan",Goal,Index),
					-current_plan(Goal,Source,Index,[]),
					 +!update_move_history[perform],
					print("RE DEBUG   achieve plan   ","Achieved Plan for ",Goal),
					+!printCurrentPlanBelief[perform],
					+!get_new_plan[perform];

+!do_all_plan_steps(Goal,Source,Index)[achieve]: {B plans(Plans),
                                B current_plan(Goal,Source,Index,PlanActions), ~B moving, ~B moving_back, ~B stopping_plan} /*done*/
									<-
									print("RE DEBUG   achieve plan   ","Not moving and have a plan for ",Goal,Index),
									+!printCurrentPlanBelief[perform],
									print("RE DEBUG   achieve plan   ","In the middle of the plan"),
									print("RE DEBUG   achieve plan   ","updating move history"),
									+!update_move_history[perform],
									print("RE DEBUG   achieve plan   ","updated move history doing actions"),
									+!doActions[perform];

+!do_all_plan_steps(Goal,Source,Index)[achieve]: {B plans(Plans),
                                B current_plan(Goal,Source,Index,PlanActions), ~B moving, ~B moving_back, B stopping_plan } /*done*/
									<-
									print("RE DEBUG   achieve plan   ","Not moving and have a plan for ",Goal,Index),
									print("RE DEBUG   achieve plan   ","In the middle of the plan"),
									print("RE DEBUG   achieve plan   ","believe stopping plan");

+!do_all_plan_steps(Goal,Source,Index)[achieve]: {B plans(Plans),
 ~B current_plan(Goal,Source,Index,Actions)
                                              ,B plan_exists(Goal,Source,Index,Actions,Vannots,Bannots),
                                              ~B moving, ~B moving_back
											} /*done*/
									<-
									print("RE DEBUG   achieve plan   ","There is no plan so new plan for ",Goal,Index),
									+!printCurrentPlanBelief[perform],
									print("RE DEBUG   achieve plan   ","Adding a new plan"),
									+current_plan(Goal,Source,Index,Actions),
									+!reset_move_history[perform],
					+!printCurrentPlanBelief[perform],
									+!doActions[perform]
									;

+!doActions[perform]: { ~B plans(Plans)} <- do_nothing;

+!doActions[perform]: { B plans(Plans),
 B current_plan(Goal,Source,Index,[FirstAction|ActionsTail]),
                       ~B stopping_plan }
					<-
					print("RE DEBUG   achieve plan   ","Performing action because no stopping plan belief",FirstAction),
					+!doAction(FirstAction)[perform],
					-current_plan(Goal,Source,Index,[FirstAction|ActionsTail]),
					+current_plan(Goal,Source,Index,ActionsTail),
					print("RE DEBUG   achieve plan   ","Added new action set ",ActionsTail),
					+!printCurrentPlanBelief[perform]
					;

+!doActions[perform]: { B plans(Plans),
 B current_plan(Goal,Source,Index,[FirstAction|ActionsTail]),
                       B stopping_plan }
					<-
					do_nothing
					;

+!printCurrentPlanBelief[perform]: {B plans(Plans),
B current_plan(Goal,Source,Index,Actions)}
<- print("RE DEBUG   print current belief   ","I believe that the current plan has",Goal,Source,Index,Actions,"Done printing current plan"),+!printMH[perform];
+!printCurrentPlanBelief[perform]:
{B plans(Plans),~B current_plan(Goal,Source,Index,Actions)}
<- print("RE DEBUG   print current belief   ","I believe that there is no current plan"),+!printMH[perform];


+!doAction(move_to(Loc))[perform]: {~B going(L1), ~B moving, ~B at(Loc), B location(Loc)
                                    } <-
							print("RE DEBUG   do action   ","moving to ",Loc),  perf(move(Loc));

+!doAction(move_to(Loc))[perform]: {B at(Loc)} <- print("RE DEBUG   do action   ","already at",Loc);

+!doAction(move_to(Loc))[perform]: {B moving} <- print("RE DEBUG    do action   ","moving already"),do_nothing;

+!doAction(move_to(Loc))[perform]: {B plans(Plans)} <- print("RE DEBUG   do action   ","have plans but something else is missing ");
+!doAction(move_to(Loc))[perform]: {True} <- print("RE DEBUG   do action   ","hmmm");
+!reset_move_history[perform]: {B move_history(MH), B plan_index(Pindex)} <- -move_history(MH),+move_history([]),-plan_index(Pindex),+plan_index(0),
									+!update_move_history[perform];

+!update_move_history[perform] : {~B at(Loc), B move_history(MH)}
							<- print("RE DEBUG   update move history   ","isnt anywhere");

+!update_move_history[perform] : {B at(Loc), B move_history(MH), B plan_index(Pindex), B moved}
    <-
    +.lock,
    +!printMH("RE DEBUG   update move history   Before update ")[perform],
    -move_history(MH),
    +move_history([move_to(Loc) | MH]),
    sum(Pindex,1,PindexOne),
    -plan_index(Pindex),
    +plan_index(PindexOne),
    remove_shared(moved),
    +!printMH("RE DEBUG update move history   After update ")[perform],
    -.lock;

+!update_move_history[perform] : {B at(Loc), B move_history([]), B plan_index(Pindex), ~B moved}
    <-
    +.lock,
    +!printMH("RE DEBUG   update move history   Before update ")[perform],
    -move_history([]),
    +move_history([move_to(Loc) | MH]),
    sum(Pindex,1,PindexOne),
    -plan_index(Pindex),
    +plan_index(PindexOne),
    +!printMH("RE DEBUG update move history   After update ")[perform],
    -.lock;

+!update_move_history[perform] : {B at(Loc), B move_history(MH), B plan_index(Pindex), ~B moved}
    <-
do_nothing;

+!get_violations(Percept)[perform]: {
        B plans(Plans),
        ~B violation_detected,
        B specification("Can violate",Specs)
        ,B can_violate(Percept,Specs,CouldViolateSpecs)
        } <-
        print("RE DEBUG   get violations   ",Percept," could violate ",CouldViolateSpecs, " from ", Specs),
        +!stop_current_plan(Percept,CouldViolateSpecs)[perform];

+!get_violations(Percept)[perform]: {
        B plans(Plans),
        B violation_detected
        } <-
       do_nothing;
+!get_violations(Percept)[perform]: {True} <- print("in get violations");
 +!stop_current_plan(Percept,[])[perform]: {B plans(Plans)} <- print("RE DEBUG  stop current plan   ","No violations possible so not stopping the plan");

 +!stop_current_plan(Percept,CouldViolateSpecs)[perform]:
                            {B plans(Plans)} <-
                            print("RE DEBUG   stop current plan   ","Stop plan"), +violation_detected, print("RE DEBUG   stop current plan   ","Need to update the specification for this plan"),
                            +!revise_annotations_action(Percept)[perform];

+!revise_annotations_action_property(near(OtherLoc))[perform]:{
              B plans(Plans),
              B current_plan(Goal,Source,Index,Actions),
              B plan_exists(Goal,Source,Index,AllActions,Vannots,Bannots),
              B at(Loc)
             ,B plan_index(Pindex)
             ,B revise_annotations(Loc,near(OtherLoc),Pindex,Vannots,Bannots,UpdatedVannots,UpdatedBannots)
                  }
                          <-
                          print("RE DEBUG   revise annotations property   ","Revising annotations"),
                          +!printPlan(Goal,Source,Index,AllActions,Vannots,Bannots)[perform],
                          print("RE DEBUG   revise annotations property   ","At loc ",Loc)
                          ,print("RE DEBUG   revise annotations property   ","Current plan ",Goal,Source,Index)
                          ,print("RE DEBUG   revise annotations property   ","Percept ",near(OtherLoc))
                          ,print("RE DEBUG   revise annotations property   ","Updated"),
                          print("RE DEBUG   revise annotations property   ","Plan index",Pindex),
                          print("RE DEBUG   revise annotations property   ","Updated Vannots",UpdatedVannots),
                          print("RE DEBUG   revise annotations property   ","Updated Bannots",UpdatedBannots),
                          +!printPlan(Goal,Source,Index,AllActions,UpdatedVannots,UpdatedBannots)[perform],
                          +!update_plan_in_plans(OtherLoc,Goal,Source,Index,AllActions,UpdatedVannots,UpdatedBannots)[perform]
                          ;

//
+!revise_annotations_action_property(near(OtherLoc))[perform]:{B plans(Plans),
                ~B current_plan(Goal,Source,Index,Actions),
              B at(Loc)
              ,B plan_index(Pindex) } <- do_nothing;


+!revise_annotations_action_property(near(OtherLoc))[perform]:{B plans(Plans),
                B current_plan(Goal,Source,Index,Actions),
              B plan_exists(Goal,Source,Index,AllActions,Vannots,Bannots),
              ~B at(SomeLoc)
              ,B plan_index(Pindex)
              ,B move_history([move_to(Loc) | T])
             ,B revise_annotations(Loc,near(OtherLoc),Pindex,Vannots,Bannots,UpdatedVannots,UpdatedBannots)
                  }
                          <-
                          print("RE DEBUG   revise annotations property   nowhere","Revising annotations"),
                          +!printPlan(Goal,Source,Index,AllActions,Vannots,Bannots)[perform],
                          print("RE DEBUG   revise annotations property   ","previous loc ",Loc)
                          ,print("RE DEBUG   revise annotations property   nowhere","Current plan ",Goal,Source,Index)
                          ,print("RE DEBUG   revise annotations property   nowhere","Percept ",near(OtherLoc))
                          ,print("RE DEBUG   revise annotations property   nowhere","Updated"),
                          print("RE DEBUG   revise annotations property   nowhere","Plan index",Pindex),
                          print("RE DEBUG   revise annotations property   ","Updated Vannots",UpdatedVannots),
                          print("RE DEBUG   revise annotations property   ","Updated Bannots",UpdatedBannots),
                          +!printPlan(Goal,Source,Index,AllActions,UpdatedVannots,UpdatedBannots)[perform],
                          +!update_plan_in_plans(OtherLoc,Goal,Source,Index,AllActions,UpdatedVannots,UpdatedBannots)[perform]
                          ;

+!revise_annotations_action_property(near(OtherLoc))[perform]:{B plans(Plans),
                B current_plan(Goal,at(Loc),Index,Actions),
              B plan_exists(Goal,Source,Index,AllActions,Vannots,Bannots),
              ~B at(SomeLoc)
              ,B plan_index(Pindex)
              ,B move_history([])
             ,B revise_annotations(Loc,near(OtherLoc),Pindex,Vannots,Bannots,UpdatedVannots,UpdatedBannots)
                  }
                          <-
                          print("RE DEBUG   revise annotations property   nowhere","Revising annotations"),
                          +!printPlan(Goal,Source,Index,AllActions,Vannots,Bannots)[perform],
                          print("RE DEBUG   revise annotations property   ","just started plan initial loc ",Loc)
                          ,print("RE DEBUG   revise annotations property   nowhere","Current plan ",Goal,Source,Index)
                          ,print("RE DEBUG   revise annotations property   nowhere","Percept ",near(OtherLoc))
                          ,print("RE DEBUG   revise annotations property   nowhere","Updated"),
                          print("RE DEBUG   revise annotations property   nowhere","Plan index",Pindex),
                          print("RE DEBUG   revise annotations property   ","Updated Vannots",UpdatedVannots),
                          print("RE DEBUG   revise annotations property   ","Updated Bannots",UpdatedBannots),
                          +!printPlan(Goal,Source,Index,AllActions,UpdatedVannots,UpdatedBannots)[perform],
                          +!update_plan_in_plans(OtherLoc,Goal,Source,Index,AllActions,UpdatedVannots,UpdatedBannots)[perform]
                          ;


+!revise_annotations_action_property(near(OtherLoc))[perform]: {True} <- print("no applicable plan for revise annotations action property near ",OtherLoc);
+!revise_annotations_action(Percept)[perform]: {B plans(Plans),
                      B current_plan(Goal,Source,Index,Actions),
                      B plan_exists(Goal,Source,Index,AllActions,Vannots,Bannots),
                      B at(Loc)
                      ,B plan_index(Pindex)
                      ,B revise_annotations(Loc,Percept,Pindex,Vannots,Bannots,UpdatedVannots,UpdatedBannots)
                      }
                      <-
                      print("RE DEBUG   revise annotations   ","Revising annotations"),
                      +!printPlan(Goal,Source,Index,AllActions,Vannots,Bannots)[perform],
                      print("RE DEBUG   revise annotations   ","At loc ",Loc)
                      ,print("RE DEBUG   revise annotations   ","Current plan ",Goal,Source,Index)
                      ,print("RE DEBUG   revise annotations   ","Percept ",Percept)
                      ,print("RE DEBUG   revise annotations   ","Updated"),
                      print("RE DEBUG   revise annotations   ","Plan index",Pindex),
                      print("RE DEBUG   revise annotations   ","Updated Vannots",UpdatedVannots),
                      print("RE DEBUG   revise annotations   ","Updated Bannots",UpdatedBannots),
                      +!printPlan(Goal,Source,Index,AllActions,UpdatedVannots,UpdatedBannots)[perform],
                      +!update_plan_in_plans(Goal,Source,Index,AllActions,UpdatedVannots,UpdatedBannots)[perform];

+!update_plan_in_plans(Loc,Goal,Source,Index,Actions,UVannots,UBannots)[perform]: {
                                    B plans(Plans),
                                    B replace_plan_annots_in_plans_revise_for_loc(Loc,Plans,Goal,Source,Index,Actions,UVannots,UBannots,NewPlans)
                                    }    <-
                                    +.lock,
                                     print("RE DEBUG   update plan in plans   ","Updating violated annots Dropping old plans ",Plans),
                                     -plans(Plans),
                                     print("RE DEBUG   update plan in plans   ","Updating violated annots Adding new plans ",NewPlans),
                                     +plans(NewPlans),
                                    +!stop_plan[achieve],
                                    -.lock;

+!update_plan_in_plans(Goal,Source,Index,Actions,UVannots,UBannots)[perform]: {
                            B plans(Plans),
                            B replace_plan_annots_in_plans(Plans,Goal,Source,Index,Actions,UVannots,UBannots,NewPlans) } <-
                          +.lock,
                          print("RE DEBUG   update plan in plans   ","Updating violated annots Dropping old plans ",Plans),
                          -plans(Plans),
                           print("RE DEBUG   update plan in plans   ","Updating violated annots Adding new plans ",NewPlans),
                          +plans(NewPlans),
                          +!stop_plan[achieve],
                           -.lock;

+!initial_setup[perform]: {True} <-
                            +.lock,
                            print("RE DEBUG   initial setup   ","Initialising helper beliefs"),
                            +!add_helper_beliefs[perform],
                            print("RE DEBUG   initial setup   ","Helper beliefs initialised"),
                           +!all_req_visits_have_plans[perform],
                           +!begin_agent[perform],
                            -.lock;

+!begin_agent[perform]: {B req_visits_have_plans} <-
            print("RE DEBUG   begin agent   ","Annotating plans"),
             +!add_plan_annotations_action [perform];

+!begin_agent[perform]: {~B req_visits_have_plans} <- print("RE  Can not proceed as all required visits do not have plans");
+!printBeliefPlans[perform] : {B plans(Plans)} <- print("RE DEBUG   print plan beliefs   ","Plans",Plans);

+check_violations(Loc): {B plans(Plans),B initial_setup_complete} <-
print("RE DEBUG   got check violations ",Loc),remove_shared(check_violations(Loc)), +!get_violations(near(Loc))[perform];

+check_violations(Loc): {B plans(Plans),~B initial_setup_complete} <-
print("RE DEBUG   got check violations ",Loc,"  initial setup not complete so doing nothing"), remove_shared(check_violations(Loc));

+check_maintain_violations(near(Loc),radiation(RadLevel)): {B plans(Plans),
    B initial_setup_complete, B specification("Maintain",MSpecs)} <-
					remove_shared(check_maintain_violations(near(Loc),radiation(RadLevel))),
					+!update_specs_with_avoid_loc(maintain(radiation(low)),Loc)[perform],
					+!revise_annotations_action_property(near(Loc))[perform]
					 ;
+check_maintain_violations(near(Loc),radiation(RadLevel)): {B plans(Plans),
        B initial_setup_complete, ~B specification("Maintain",MSpecs)} <-
        remove_shared(check_maintain_violations(near(Loc),radiation(RadLevel))),
        +!get_violations(near(Loc))[perform];

+check_maintain_violations(Loc): {B plans(Plans),~B initial_setup_complete} <-
            remove_shared(check_maintain_violations(near(Loc),radiation(RadLevel)));

+!printMH[perform]:{True} <- +!printMH("RE DEBUG   print MH   ")[perform];
+!printMH(PrefixText)[perform] : { B move_history(MH), B plan_index(Pindex) } <-
							append(PrefixText," MH ", Text),
							print("RE DEBUG   print MH   ",Text,MH),
							print("RE DEBUG   print MH   ","Plan Index ",Pindex);

+!appendPrint(PString,PVar)[perform] : {True} <-
							 +.lock,
							 toString(PVar,PVarS),
							 append(PString,PVarS,PrintV),
							print(PrintV),
							-.lock;

+!printPlan(Goal,Source,PlanIndex,PlanActions,PlanAnnotsV,PlanAnnotsB)[perform]: {True} <-
	+.lock,

	toString(Goal,PG),
	toString(PlanIndex,PIS),
					toString(PlanActions,PAS),
					toString(PlanAnnotsV,PAnSV),
					toString(PlanAnnotsB,PAnSB),
					append(PAnSV,PAnSB,PAnS),
					toString(Source,SrcS),
					append(" Index ",PIS,P1),
					append(" Actions ",PAS,P2),
					append(" Annotations ",PAnS, P3),
					append(" Source ", SrcS,P4),

					append(P1,P2,PP1),
					append(PP1,P3,PP2),
					append(PG," ",PPG),
					append(PPG,P4,PP4),
					append(PP4,PP2,PP3),
					print("RE DEBUG  print plan    ",PP3),
					-.lock;
