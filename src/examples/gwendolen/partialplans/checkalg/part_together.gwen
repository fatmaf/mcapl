GWENDOLEN

// putting it all together 
// 1. we find a plan 
// using the entire specification 
// this uses the weakening and non-weakening bit 
// 2. we execute the plan 


:name: planexecutorA

:Initial Beliefs:

//visited(l0,0)
//visited(l1,1)
//visited(l4,2)
//just to count the locations
location_count(0)


//to record movement
move_history([])

//plans
//plans([
//				plan(Goal/destination, source, index, actions, annotations )...])

plans([ 
        plan(visit(l1),at(l0),1, [move_to(l1)], [visit(l1), avoid(l6)]),
        plan(visit(l1),at(l0),2, [move_to(l2), move_to(l1)], [visit(l1), avoid(l6)]),
        plan(visit(l1),at(l0),3, [move_to(l2), move_to(l3), move_to(l4), move_to(l5), move_to(l1)], [visit(l1), avoid(l6)]),
        plan(visit(l3),at(l1),1, [ move_to(l4), move_to(l5), move_to(l3)],[visit(l3), visit(l5), avoid(l6)]),
        plan(visit(l3),at(l1),2, [move_to(l2), move_to(l3)], [visit(l3),  avoid(l6)]),
        plan(visit(l5),at(l3),1, [move_to(l4), move_to(l5)], [visit(l5),  avoid(l6)]),
        plan(visit(l5),at(l3),2, [move_to(l2), move_to(l1), move_to(l5)], [visit(l5),  avoid(l6)])
    ])

specification("Required",[visit(l1),visit(l3),visit(l5)])
specification("Preferred",[before(l1,l3),before(l1,l5),before(l3,l5),avoid(l6)])

:Reasoning Rules:
//the basics
ismember(H, [H | T]);
ismember(H, [X | T]) :-
	ismember(H,T);
	
append([], X, X);
append([ H | T], X , [ H | W ]) :- 
	append(T,X,W);

remove_from_list(Elem,[],[]);
remove_from_list(Elem,[Elem|L],L);
remove_from_list(Elem,[NotElem | L],[NotElem | NL]):-
	remove_from_list(Elem,L,NL);

remove_list_from_list([],L,L);	
remove_list_from_list([ToRemoveH | ToRemoveT ],L,NL):-
	remove_from_list(ToRemoveH,L,NL1),
	remove_list_from_list(ToRemoveT,NL1,NL); 


replaceFirst(_,_, [],[]);
replaceFirst(O,R,[O|T],[R|T]);
replaceFirst(O,R,[H|T],[H|T2]) :- 
			dif(H,O),
			replaceFirst(O,R,T,T2);

//combining the required and preferred specs
combined_specifications(CSpecs):-
	specification("Required",RSpec),
	specification("Preferred",PSpec),
	append(RSpec,PSpec,CSpecs);

//checking if a spec is satisfied 
satisfied(before(Per,Loc)):-
	visited(Per,Tp),
	visited(Loc,Tl),
	[Tp < Tl];
	
satisfied(before(Per,Loc)):-
	visited(Per,Tp),
	~visited(Loc,Tl);
		
satisfied(before(Loc,Per)):-
	visited(Loc,Tl),
	visited(Per,Tp),
	[Tl < Tp];
	
satisfied(visit(Per)):-
	visited(Per,Tp);
	
satisfied_avoid(avoid(Per)):-
	~visited(Per,Tp);
	
//removing satisfied specs from list 
filter_satisfied_specs([],[]);
filter_satisfied_specs([OrigSpecsH | OrigSpecsT], FiltSpecs):-
	satisfied(OrigSpecsH),
	filter_satisfied_specs(OrigSpecsT,FiltSpecs);
filter_satisfied_specs([OrigSpecsH | OrigSpecsT], [OrigSpecsH | FiltSpecs]):-
	filter_satisfied_specs(OrigSpecsT,FiltSpecs);
	
//when we're all done we'll only have avoid specs 
//so we can check if all we're left with is avoid specs 
//and just say we're done 
avoid_specs_only([]);
avoid_specs_only([avoid(X) | T]):-
	avoid_specs_only(T);

//checking if a spec is violated 
//have to avoid a location
violated(Per,avoid(Per));

//if we were to visit per before loc
//and we've already visited loc
//and we haven't visited per 
//then we're going to violate this
violated(Per,before(Per,Loc)):-
	visited(Loc,Tloc),
	~visited(Per,Tper);
//if we have visited per before then
//we're not likely to violate the spec 

//if we were to visit loc before per 
//and we haven't visited loc 
//then we'll violate this 
violated(Per,before(Loc,Per)):-
	~visited(Loc,Tloc);
	

violated_before(before(Loc1,Loc2)):-
    ~visited(Loc1,Tloc1),
    visited(Loc2,TLoc2);	

//getting all violated specs
violated_specifications(Per,[],[]);
	
violated_specifications(Per,[OrigSpecsH | OrigSpecsT],[OrigSpecsH | ViolSpecT]):-
	//so we get all the violated specifications 
	violated(Per,OrigSpecsH),
	violated_specifications(Per,OrigSpecsT,ViolSpecT);
	
violated_specifications(Per,[OrigSpecsH | OrigSpecsT], ViolSpecT):-
	violated_specifications(Per,OrigSpecsT,ViolSpecT);

select_all_plans_for_spec(Spec,[],[]);
select_all_plans_for_spec(Spec,[plan(Spec,Src,Index,Actions,Annots) | Tplans],[plan(Spec,Src,Index,Actions,Annots) | OtherPlans]):-
	select_all_plans_for_spec(Spec,Tplans,OtherPlans);
select_all_plans_for_spec(Spec,[plan(NotSpec,Src,Index,Actions,Annots) | Tplans],OtherPlans):-
	select_all_plans_for_spec(Spec,Tplans,OtherPlans);
		
//find the first spec we have a plan for 
first_spec_with_plan([],[],[]);

first_spec_with_plan([H | T],Spec,Rest):-
	plans(L),
	select_all_plans_for_spec(H,L,[]),
	first_spec_with_plan(T,Spec,Rest);
	

first_spec_with_plan([H | T],Spec,Res):-
	plans(L),
	select_all_plans_for_spec(H,L,Res);
	
//remove all specs from list that have plans except specified spec 
has_plans(Spec):-
	plans(L),
	select_all_plans_for_spec(Spec,L,Plans);

remove_plan_specs([],[],[]);
remove_plan_specs([HSL | TSL],OtherSpecs,[HSL | PlanSpecs] ):-
	has_plans(HSL),
	remove_plan_specs(TSL,OtherSpecs,PlanSpecs);
remove_plan_specs([HSL | TSL],[HSL | OtherSpecs],PlanSpecs ):-
	remove_plan_specs(TSL,OtherSpecs,PlanSpecs);

//find the first spec that has a plan and return that list of plans
first_spec_with_plan(Spec,AllSpecPlans):-

	updated_specifications("Required",RSpec),
	updated_specifications("Preferred",PSpec),
	//combine these 
	append(RSpec,PSpec,CSpec),
	
	//find the first spec we have a plan for 
	first_spec_with_plan(CSpec,Spec,AllSpecPlans);

//get a required spec without any of the specs we have plans for 
//spec - is the spec the planset is for (see first spec with plan)
//NewRNoPlanSpec is the updated req spec 
//NewRPlanSpec is the list of all the removed specs from req spec 
//we need the above for pspec_modified
rspec_with_no_otherplanspecs(Spec,NewRNoPlanSpec,NewRPlanSpec):-

	updated_specifications("Required",RSpec),
	remove_plan_specs(RSpec,RNoPlanSpec,RPlanSpec),
	remove_from_list(Spec,RPlanSpec,NewRPlanSpec),
	append([Spec],RNoPlanSpec,NewRNoPlanSpec);

//get an updated preferred spec
//the input is the list of specs from rspec we removed 
//cuz we had plans for them 
//weakening spec is the spec we get by tacking things on 
//and essentially not caring 
pspec_modified(NewRPlanSpec,WeakeningSpec):-

	updated_specifications("Preferred",PSpec),
	remove_plan_specs(PSpec,PNoPlanSpec,PPlanSpec),
	append(PNoPlanSpec,PPlanSpec,NewPPlanSpec),
	append(NewPPlanSpec,NewRPlanSpec,WeakeningSpec);

//helper stuff for plans 
get_plans_for_spec(S,[],[]);

get_plans_for_spec(S, [plan(G,X,Ind,Actions,HP) | TP], [plan(G,X,Ind,Actions,HP) | Res]) :-
	ismember(S,HP),
	get_plans_for_spec(S,TP,Res);  
	
get_plans_for_spec(S,[plan(G,X,Ind,Actions,HP) | TP], Res) :-
	get_plans_for_spec(S,TP,Res);

//getting plans without weakening 	
get_plans_for_speclist_no_weakening([],Plans,Plans);	
 
get_plans_for_speclist_no_weakening([H|T],Plans,PossiblePlans):-
	get_plans_for_spec(H,Plans,PlanSet),
	get_plans_for_speclist_no_weakening(T,PlanSet,PossiblePlans);

//more helper things 
check_plans_for_spec(L,[],L);
check_plans_for_spec(L,NL,NL);


get_plans_for_speclist_weakening_wrapper(NotGoalsList,Preferred,Plans,PossiblePlans):-
    append(NotGoalsList,Preferred,SpecsForPlans),
    get_plans_for_speclist_weakening(SpecsForPlans,Plans,PossiblePlans);
    
//getting plans with weakening 
get_plans_for_speclist_weakening([],Plans,Plans);	
 
get_plans_for_speclist_weakening([H|T],Plans,PossiblePlans):-
	get_plans_for_spec(H,Plans,PlanSet),
	check_plans_for_spec(Plans,PlanSet,NewPlanSet),
	get_plans_for_speclist_weakening(T,NewPlanSet,PossiblePlans);
			

//finding a plan 
plan_exists(CurrentLoc,Goal,PlanIndex,PlanActions,
			PlanAnnots,[plan(Goal,CurrentLoc,PlanIndex,PlanActions,PlanAnnots) | T]);


plan_exists(CurrentLoc,Goal,PlanIndex,PlanActions,PlanAnnots,[H | T]):-
	plan_exists(CurrentLoc,Goal,PlanIndex,PlanActions,PlanAnnots,T);
	
plan_exists(Goal,Source,PlanIndex,PlanActions,PlanAnnots):-
	plans(L),
	plan_exists(Source,Goal,PlanIndex,PlanActions,PlanAnnots,L);


check_length(L,Len):-
	length(L,Len);
	
//updating plans 
//
updated_plans(PlanIndex,L,NewPlanAnnots,NewL):-
	replaceFirst(plan(G,Source,PlanIndex,PlanActions,PlanAnnots),plan(G,Source,PlanIndex,PlanActions,NewPlanAnnots),L,NewL);


  plan_exists_from(Loc,[],[]);
  plan_exists_from(Loc,[plan(Goal,at(Loc),Index,Actions,Annotations)|T],
                                  [plan(Goal,at(Loc),Index,Actions,Annotations)|PlanSet]):-
                                  plan_exists_from(Loc,T,PlanSet);
  plan_exists_from(Loc,[H|T],PlanSet):-
                                  plan_exists_from(Loc,T,PlanSet);


  get_plans_for_goal(Goal,[],[]);
  get_plans_for_goal(Goal,[plan(Goal,at(Loc),Index,Actions,Annotations)|T],
                                  [plan(Goal,at(Loc),Index,Actions,Annotations)|PlanSet]):-
                                  get_plans_for_goal(Goal,T,PlanSet);
  get_plans_for_goal(Goal,[H|T],PlanSet):-
                                  get_plans_for_goal(Goal,T,PlanSet);

dif(X,Y):- ~[X == Y];
//dif(Loc1,Loc2);

check_before([],before(Loc1,Loc2));
check_before([move_to(Loc1)|T],before(Loc1,Loc2)):- dif(Loc1,Loc2);
//            check_before_after(T,before(Loc1,Loc2));
check_before([move_to(Loc2)|T],before(Loc1,Loc2)):- dif(Loc1,Loc2),false;
check_before([move_to(Loc)|T],before(Loc1,Loc2)):-
            dif(Loc,Loc2),
            dif(Loc,Loc1),
            check_before(T,before(Loc1,Loc2));

//check_before_after([],before(Loc1,Loc2));
//check_before_after([move_to(Loc2)|T],before(Loc1,Loc2));
//check_before_after([move_to(Loc)|T],before(Loc1,Loc2)):-
//            dif(Loc,Loc2),
//            dif(Loc,Loc1),
//            check_before_after(T,before(Loc1,Loc2));

//%so now we want to annotate a plan
//%given a plan P we go over it to check before
//%if it returns true we add the annotation to it
annotate_plan_with_before(plan(Goal,Dest,Index,Actions,Annots),before(Loc1,Loc2) ):-
    check_before(Actions,before(Loc1,Loc2));


//so you have a plan and the annotations list
// you just go over each before and annotate it
// hmmm so we just need a reasoning rule
annotate_plan_with_befores(Plan,[],[]);
annotate_plan_with_befores(Plan,[HBSpecs | TBSpecs],[HBSpecs | UAnnots]):-
    annotate_plan_with_before(Plan,HBSpecs),
    annotate_plan_with_befores(Plan,TBSpecs,UAnnots);
annotate_plan_with_befores(Plan,[HBSpecs | TBSpecs], UAnnots):-
    annotate_plan_with_befores(Plan,TBSpecs,UAnnots);

annotate_plans_with_befores([],BSpecs,[]);
annotate_plans_with_befores([plan(Goal,Dest,Index,Actions,Annots) | TPlans],BSpecs,[plan(Goal,Dest,Index,Actions,NewAnnots) | NewPlans]):-
    annotate_plan_with_befores(plan(Goal,Dest,Index,Actions,Annots),BSpecs,AddAnnots),
    append(Annots,AddAnnots,NewAnnots),
    annotate_plans_with_befores(TPlans,BSpecs,NewPlans);



//getting a list of all befores
//basically we have a list of specs and we just check if each element is a before
//and if it is we add it to our list
befores_list([],[]);
befores_list([before(Loc1,Loc2) | TCSpecs],BSpecs):-
    violated_before(before(Loc1,Loc2)),
//        print("Violated before"),
    befores_list(TCSpecs,BSpecs);
befores_list([before(Loc1,Loc2) | TCSpecs],BSpecs):-
    satisfied(before(Loc1,Loc2)),
    befores_list(TCSpecs,BSpecs);
befores_list([before(Loc1,Loc2) | TCSpecs],[before(Loc1,Loc2) | BSpecs]):-
    befores_list(TCSpecs,BSpecs);
befores_list([HCSpecs | TCSpecs],BSpecs):-
    befores_list(TCSpecs,BSpecs);

//so you get the goals list one time
//then you can add it as a belief so you dont
//need it
get_plan_goals_list([],[]);
get_plan_goals_list([plan(Goal,Source,Index,Actions,Annots) | TPlans], GoalsList):-
    get_plan_goals_list(TPlans,GoalsList),
    ismember(Goal,GoalsList);
get_plan_goals_list([plan(Goal,Source,Index,Actions,Annots) | TPlans], [Goal |GoalsList]):-
    get_plan_goals_list(TPlans,GoalsList);

//you get the nongoals list one time
//so you can just add it as a belief too
break_required_specs_into_goals_and_not_goals([],GoalsList,[]);
break_required_specs_into_goals_and_not_goals([HSpec | TSpec],GoalsList,NotGoalsList):-
    ismember(HSpec,GoalsList),
    break_required_specs_into_goals_and_not_goals(TSpec,GoalsList,NotGoalsList);
break_required_specs_into_goals_and_not_goals([HSpec | TSpec],GoalsList,[HSpec | NotGoalsList]):-
    break_required_specs_into_goals_and_not_goals(TSpec,GoalsList,NotGoalsList);

//finally for each plan
//we want to be able to remove the goal from the list
//create a new list [goal, notgoals, preferred, goals]
create_specifications_for_plan(Goal,NotGoalsList,Preferred,GoalsList,SpecsForPlan):-
    remove_from_list(Goal,GoalsList,MinusGoalsList),
    append([Goal],NotGoalsList,TempList),
    append(TempList,Preferred,TempList2),
    append(TempList2,MinusGoalsList,SpecsForPlan);
	
			
:Initial Goals:

findplan[perform]

:Plans:

+!set_up_initial_beliefs[perform]: {B goalslist(G), B nongoalslist(Ng)
                                    } <-
                                    print("Goals list"),
                                    print(G),
                                    print("Non goals list"),
                                    print(Ng),
                             
                                    +!get_plans[perform];
//                                    +!test_belief_addition[perform];

+!set_up_initial_beliefs[perform]: {~B goalslist(G), ~B nongoalslist(Ng),B plans(AllPlans), B get_plan_goals_list(AllPlans,GoalsList),
                                    B specification("Required",RSpec), B break_required_specs_into_goals_and_not_goals(RSpec,GoalsList,NonGoalsList)
                                    } <-
                                    print("Goals list"),
                                    print(GoalsList),
                                    print("Non goals list"),
                                    print(NonGoalsList),
                                    +goalslist(GoalsList),
                                    +nongoalslist(NonGoalsList),
                                    +!get_plans[perform];
//                                    +!test_belief_addition[perform];

+!test_belief_addition[perform]: {B goalslist(G), B nongoalslist(Ng)} <-
                                    print("Checking beliefs"),
                                    print(G),
                                    print(Ng);
+!get_plans[perform]: {~B at(Loc)} <- print("dont believe im anywhere so will try again"), +!get_plans[perform];
+!get_plans[perform]: {B at(Loc)} <- +!get_plans_from(Loc)[perform];
+!get_plans_from(Loc)[perform] : {
                                  B plans(AllPlans),
                                  B plan_exists_from(Loc,AllPlans,LocPlans)
                                  }
                                  <-
                                  +!appendPrint("Seems like there are plans from ",Loc)[perform],
                                  print(LocPlans),
                                  +!get_befores_list(LocPlans)[perform];

+!get_befores_list(LocPlans)[perform] : {B combined_specifications(CSpecs),
                               B befores_list(CSpecs,BSpecs) }
                               <-
                               print("Before specs list"),
                               print(BSpecs),
                               +!check_before_annots(LocPlans,BSpecs)[perform];

+!check_before_annots([],BSpecs)[perform] : { True
                                        }
                                      <-
                                     print("All done")
                                      ;
+!check_before_annots(LocPlans,BSpecs)[perform] : { B annotate_plans_with_befores(LocPlans,BSpecs,NewPlans)
,B combined_specifications(CSpecs)
                                        }
                                      <-
                                      print("Checking annots"),
                                      print(LocPlans),
                                      print("Updated annots"),
                                      print(NewPlans)
//                                      , print("Combined specs"),
//                                                                               print(CSpecs)

                                      ,
                                      +!find_valid_plans(NewPlans)[perform]
                                      ;
+!find_valid_plans(NewPlans)[perform] : {B specification("Preferred",PSpecs),
                                        B nongoalslist(Ng),
                                        B get_plans_for_speclist_weakening_wrapper(Ng,PSpecs,NewPlans,ChosenPlans)
                                        }  <-
                                        print("Combined specs"),
                                        print(Ng),
                                        print(PSpecs)
                                        ,
                                        print("ChosenPlans"),
                                        print(ChosenPlans),
                                        +!select_first_plan(ChosenPlans)[perform]
                                        ;
                                        

+!findplan[perform]: {True} <-
				+!set_up_initial_beliefs[perform];
				
+!get_first_spec_plans[perform]: {B first_spec_with_plan(Spec,AllSpecPlans)} <-
					+!appendPrint("Found plan for ", Spec)[perform],
					+!appendPrint("Plan set ", AllSpecPlans)[perform],
					
					+!find_plans_no_weakening(Spec,AllSpecPlans)[perform];
					
					
+!find_plans_no_weakening(Spec,AllSpecPlans)[perform] : {B rspec_with_no_otherplanspecs(Spec,NewRNoPlanSpec,NewRPlanSpec),
														B get_plans_for_speclist_no_weakening(NewRNoPlanSpec,AllSpecPlans,FixedPlans)}
											 <- 
											 +!appendPrint("Updated required spec ",NewRNoPlanSpec)[perform],
											 +!appendPrint("Removed specs ",NewRPlanSpec)[perform],
											 +!appendPrint("We got some plans ",FixedPlans)[perform],
											 +!find_plans_weakening(Spec,NewRPlanSpec,FixedPlans)[perform]; 	
											 
+!find_plans_weakening(Goal,NewRPlanSpec,SpecPlans)[perform]: {B pspec_modified(NewRPlanSpec,WeakeningSpec),
														  B get_plans_for_speclist_weakening(WeakeningSpec,SpecPlans,WeakenedPlans)} 
											<-
											+!appendPrint("Removed specs from req ",NewRPlanSpec)[perform],
											+!appendPrint("Weakening spec ", WeakeningSpec)[perform],
											+!appendPrint("Weakended plans ",WeakenedPlans)[perform],
											+!select_first_plan(Goal,WeakenedPlans)[perform];

+!select_first_plan([]) [perform] : {True} <- print("Goal and plans are empty"), print("Either all specs are achieved"),
											print("Or something strange happened");											
+!select_first_plan([plan(Goal,Source,Index,Actions,Annotations) |T])[perform] : {True} <- 
											print("Got plan"),
											+!printPlan(Goal,Source,Index,Actions,Annotations)[perform],
											+!achieve_plan(Goal,Index)[achieve];	
														
+!update_specs[perform]: {True} 
					<- 
					+!update_specs("Required")[perform],
					+!update_specs("Preferred")[perform];
									
+!update_specs(Type)[perform]: {~B updated_specifications(Type,SpecList), B specification(Type,RSpec)}
				<- +!update_specs(Type,RSpec)[perform];
				
+!update_specs(Type)[perform]: {B updated_specifications(Type,SpecList)}
				<- +!update_specs(Type,SpecList)[perform];
								
+!update_specs(Type,SpecList)[perform]: {
									 B filter_satisfied_specs(SpecList,FiltSpecList)}
						<-
						+!appendPrint("Spec Type ",Type)[perform],
						+!appendPrint("Old ",SpecList)[perform],
						+!appendPrint("New ",FiltSpecList)[perform],
						-updated_specifications(Type,SpecList),
						+updated_specifications(Type,FiltSpecList)
						;
						
+!stop_plan(l5)[perform]: {B current_plan(Goal,Index,PA)} 
					<- print("Stopping plan"),
					-!achieve_plan(Goal,Index)[achieve];
					
					
+!stop_plan(Loc)[perform]: {B current_plan(Goal,Index,PA)} 
					<- print("Not stopping the plan");
					
+!stop_moving[perform]: {B moving} <-
						print("Stop moving"),
						-moving;

						
+!stop_plan[perform]: {B current_plan(Goal,Index,PA),
						~B moving} 
					<- 
					print("Stopping plan not moving"),
					-!achieve_plan(Goal,Index)[achieve],
					+!move_back[achieve];
											
+!stop_plan[perform]: {B current_plan(Goal,Index,PA),
						B moving} 
					<- 
					+!stop_moving[perform],
					print("Stopping plan"),
					-!achieve_plan(Goal,Index)[achieve],
					+!move_back[achieve];
					
-!achieve_plan(Goal,Index)[achieve]: {True} <- -current_plan(Goal,Index),
												print("Plan stopped");		
																			
+!achieve_plan(Goal,Index)[achieve]: {~B current_plan(Goal,Index,PlanActions),
											  B plan_exists(Goal,Source,Index,Actions,Annots)
											} 
									<-
									+current_plan(Goal,Index,Actions),
									+.lock,
									+!reset_move_history[perform],
									+!update_move_history[perform],
									-.lock,
									+!printPlan(Goal,Source,Index,Actions,Annots)[perform],
									+!doActions[perform];


+!achieve_plan(Goal,Index)[achieve]: {B current_plan(Goal,Index,[])
											} 
									<-
									
									+achieve_plan(Goal,Index),
									print("Removed belief of current plan"),
									print(Goal),
									print(Index),
									-current_plan(Goal,Index,[]),
									+!update_move_history[perform],
									+!appendPrint("Achieved Plan for ",Goal)[perform],
									+!findplan[perform];
									
+!achieve_plan(Goal,Index)[achieve]: {B current_plan(Goal,Index,PlanActions)
											} 
									<-
									+!update_move_history[perform],
									+!doActions[perform];

+!move_back[achieve]:{B move_history([FAct|TActs]),
					  ~B move_back_list(MBL)} 
					  <-
					  
					  +!stop_moving[perform],
					  +move_back_list([FAct|TActs]),
					  +!doMoveBackActions[perform];



+!move_back[achieve]:{B move_back_list([])
					  } 
					  <-
					  print("Moved back"),
					  -move_back_list([]),
					  +move_back,
					  +!findplan[perform]
					  ;

+!move_back[achieve]:{B move_back_list([FAct|TActs])
					  } 
					  <-
					  
					  +!doMoveBackActions[perform];
					  
					  
+!doMoveBackActions[perform]: {B move_back_list([FAct|TActs]) }
					<-
					+!doAction(FAct)[perform],
					-move_back_list([FAct|TActs]),
					+move_back_list(TActs)
					;
					
+!doActions[perform]: {B current_plan(Goal,Index,[FirstAction|ActionsTail])}
					<-
					+!doAction(FirstAction)[perform],
					-current_plan(Goal,Index,[FirstAction|ActionsTail]),
					+current_plan(Goal,Index,ActionsTail)
					;
					
/**
+!doActionsMoveBack[achieve]: {B move_history([FirstAction|ActionsTail]),
							   ~B moving_back,
							   ~B move_back_list(MBL)}
					<-
					+!stop_moving[perform],
					print("Attempting to move back"),
					+!appendPrint("First action",FirstAction)[perform],
					+!appendPrint("Tail ",ActionsTail)[perform],
					+moving_back,
					+move_back_list(ActionsTail),
					+!doAction(FirstAction)[perform]
					;					
					

+!doActionsMoveBack[achieve]: {B move_history(MH),
							   B moving_back,
							   B move_back_list([])}
					<-
					-move_back_list([]),
					-moving_back,
					+!reset_move_history[perform],
					+doActionsMoveBack,
					print("Moved back now waiting")
					;	

+!doActionsMoveBack[achieve]: {B move_history(MH),
							   B moving_back,
							   B move_back_list([FirstAction|ActionsTail])}
					<-
					+!stop_moving[perform],
					-move_back_list([FirstAction|ActionsTail]),
					+move_back_list(ActionsTail),
					+!doAction(FirstAction)[perform]
					;					
**/
					
+!doAction(move_to(Loc))[perform]: {~B moving, ~B at(Loc)}
							<- 
							+moving,
							move_to(Loc);
							
+!doAction(move_to(Loc))[perform]: {B at(Loc)}
							<- 
							print("Already at location");
+!doneMove(Loc)[perform]: {~B moving} <- do_nothing;							
+!doneMove(Loc)[perform]: {B moving}
							<-
							print("done move"),
							+doAction(move_to(Loc)),
							-moving;

+!reset_move_history[perform]: {B move_history(MH)} <- -move_history(MH),+move_history([]);														
+!update_move_history[perform] : {~B at(Loc), B move_history(MH)} 
							<- 
							print("isnt anywhere");
							
+!update_move_history[perform] : {B at(Loc), B move_history(MH)} 
							<- 
							+!visitedLoc(Loc)[perform],
							+!printMH("Before update ")[perform],
							-move_history(MH),
							+move_history([move_to(Loc) | MH]),
							+!printMH("After update ")[perform];
							
									
+at(Loc): {True} <- 
			+.lock,
			+!visitedLoc(Loc)[perform],
			+!doneMove(Loc)[perform],
			+!appendPrint("Visited ",Loc)[perform],
			-.lock;			
			
						
+!visitedLoc(Loc)[perform] : {B location_count(C), ~B visited(Loc,C)}
						<-
						+visited(Loc,C),
						-location_count(C),
						sum(C,1,NewC),
						+location_count(NewC);

+near(Loc): {B combined_specifications(CSpecs) } <- 
					+!appendPrint("Original Specs ",CSpecs)[perform],
					+!appendPrint("Near ", Loc)[perform],
					+!get_violations(Loc,CSpecs)[perform];						
						
+!get_violations(Loc,OrigSpec)[perform]: {B violated_specifications(Loc,OrigSpec,VSpecs),
									 B current_plan(Goal,PlanIndex,PActions)}
						<-
						+!appendPrint("Violated specs ",VSpecs)[perform],
						+!appendPrint("Current plan goal",Goal)[perform],
						+!appendPrint("Current plan index", PlanIndex)[perform],
						+!update_annotations(Goal,PlanIndex,VSpecs)[perform];
						


+!update_annotations(Goal,PlanIndex,ViolatedSpecs)[perform]: {
							B plan_exists(Goal,Source,PlanIndex,PlanActions,PlanAnnots),
							B remove_list_from_list(ViolatedSpecs,PlanAnnots, NewPlanAnnots)} 
						<-
						// we believe this plan exists 
						+.lock,
						+!appendPrint("Violated list ",ViolatedSpecs)[perform],
						+!appendPrint("Old annotations ",PlanAnnots)[perform],
						+!appendPrint("Updated annots ",NewPlanAnnots)[perform],
						+!update_plans(Goal,PlanIndex,NewPlanAnnots)[perform],
						-.lock;
						
+!update_plans(Goal,PlanIndex,NewPlanAnnots)[perform]: { B plans(L),
							B updated_plans(PlanIndex,L,NewPlanAnnots,NewL)}
							<-
							+.lock,
							//drop the old plans belief 
							-plans(L), 
							print("Dropped old plans"),
							print(L),
							//add in the new one 
							+plans(NewL),
							print("Added new ones"),
							print(NewL),
							-.lock,
							+!stop_plan[perform]
							;		


						
+!printMH(PrefixText)[perform] : {B move_history(MH)} 
							<-
							append(PrefixText," MH ", Text),	
							+!appendPrint(Text,MH)[perform];						
+!appendPrint(PString,PVar)[perform] : {True} <- 
							 +.lock,
							 toString(PVar,PVarS),
							 append(PString,PVarS,PrintV),
							print(PrintV),
							-.lock;
							
+!printPlan(Goal,Source,PlanIndex,PlanActions,PlanAnnots)[perform]: {True} <-
	+.lock,
	toString(Goal,PG),
	toString(PlanIndex,PIS),
					toString(PlanActions,PAS),
					toString(PlanAnnots,PAnS),
					toString(Source,SrcS),
					append(" Index ",PIS,P1),
					append(" Actions ",PAS,P2),
					append(" Annotations ",PAnS, P3), 
					append(" Source ", SrcS,P4),
					
					append(P1,P2,PP1),
					append(PP1,P3,PP2),
					append(PG," ",PPG),
					append(PPG,P4,PP4),
					append(PP4,PP2,PP3),
					print(PP3),
					-.lock;						
									
									
					