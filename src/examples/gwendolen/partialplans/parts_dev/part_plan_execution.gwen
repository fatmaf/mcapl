GWENDOLEN

// in this part we test 
// plan execution 
// we test our ability to 
// execute a plan completely 
// stop after x indices 
// stop on percept 


:name: planexecutorA

:Initial Beliefs:

//just to count the locations
location_count(0)

//to record movement
move_history([])

//plans
//plans(Goal/destination, [
//				plan(source, index, actions, annotations )...])

plans(visit(l1),[ 
        plan(at(l0),1, [move_to(l1)], [at(l1),before(l1,l3),before(l1,l5),before(l3,l5), avoid(l6)]),
        plan(at(l0),2, [move_to(l2), move_to(l1)], [at(l1),before(l1,l3),before(l1,l5),before(l3,l5), avoid(l6)]),
        plan(at(l0),3, [move_to(l2), move_to(l3), move_to(l4), move_to(l5), move_to(l1)], [at(l1), before(l3,l5), avoid(l6)])
    ])
    
                
plans(visit(l3),[ 
        plan(at(l1),1, [ move_to(l4), move_to(l5), move_to(l3)],[at(l3), at(l5), before(l1,l3), before(l1,l5), before(l3,l5),avoid(l6)]),
        plan(at(l1),2, [move_to(l2), move_to(l3)], [at(l3), before(l1,l3), before(l1,l5), before(l3,l5), avoid(l6)])
    ])

plans(visit(l5),[ 
        plan(at(l3),1, [move_to(l4), move_to(l5)], [at(l5), before(l1,l3),before(l3,l5) ,before(l1,l5), avoid(l6)]),
        plan(at(l3),2, [move_to(l2), move_to(l1), move_to(l5)], [at(l5), before(l1,l3),before(l1,l5),before(l3,l5), avoid(l6)])
    ])


:Reasoning Rules:
//the basics
ismember(H, [H | T]);
ismember(H, [X | T]) :-
	ismember(H,T);
	
append([], X, X);
append([ H | T], X , [ H | W ]) :- 
	append(T,X,W);

remove_from_list(Elem,[],[]);
remove_from_list(Elem,[Elem|L],L);
remove_from_list(Elem,[NotElem | L],[NotElem | NL]):-
	remove_from_list(Elem,L,NL);

remove_list_from_list([],L,L);	
remove_list_from_list([ToRemoveH | ToRemoveT ],L,NL):-
	remove_from_list(ToRemoveH,L,NL1),
	remove_list_from_list(ToRemoveT,NL1,NL); 


replaceFirst(_,_, [],[]);
replaceFirst(O,R,[O|T],[R|T]);
replaceFirst(O,R,[H|T],[H|T2]) :- 
			dif(H,O),
			replaceFirst(O,R,T,T2);

//finding a plan 
plan_exists(CurrentLoc,Goal,PlanIndex,PlanActions,PlanAnnots,[plan(CurrentLoc,PlanIndex,PlanActions,PlanAnnots) | T]);


plan_exists(CurrentLoc,Goal,PlanIndex,PlanActions,PlanAnnots,[H | T]):-
	plan_exists(CurrentLoc,Goal,PlanIndex,PlanActions,PlanAnnots,T);
	
plan_exists(Goal,Source,PlanIndex,PlanActions,PlanAnnots):-
	plans(Goal,L),
	plan_exists(Source,Goal,PlanIndex,PlanActions,PlanAnnots,L);



:Initial Goals:

achieve_plan(visit(l1),at(l0),2)[perform]

:Plans:
// when we dont have a plan 
// we check if a plan exists, if it doesnt meh
+!achieve_plan(Goal,Source,PlanIndex)[perform]: {~B current_plan(Goal,PlanIndex),
												~B plan_exists(Goal,Source,PlanIndex,PlanActions,PlanAnnots) 
												 } 
									<-
									+!appendPrint("No plan exists for ",Goal)[perform],
									+!appendPrint("from ",Source)[perform],
									+!appendPrint(" with index ",PlanIndex)[perform],
									-!achieve_plan(Goal,Source,PlanIndex)[perform],
									print("Dropped goal");
									
// when we dont have a plan 
// we check if a plan exists and then execute the first move
+!achieve_plan(Goal,Source,PlanIndex)[perform]: {~B current_plan(Goal,PlanIndex),
												B plan_exists(Goal,Source,PlanIndex,[PlanActionsH | PlanActionsT],PlanAnnots) 
												 } 
									<-
									+.lock,
									+!printPlan(Goal,Source,PlanIndex,[PlanActionsH | PlanActionsT],PlanAnnots)[perform],
									+next_move(PlanActionsH),
									+remaining_plan(PlanActionsT),
									+current_plan(Goal,PlanIndex),
									+!execute_next_move[perform],
									+!achieve_plan(Goal,Source,PlanIndex)[perform],
									-.lock;
									
//after the first move, we check if we've completed the plan 
//if so we say we're done
+!achieve_plan(Goal,Source,PlanIndex)[perform]: {B current_plan(Goal,PlanIndex),
												 ~B next_move(Move), 
												 ~B remaining_plan(PlanActions),
												 ~B executing_move
												 }
									<- 
									print("Achieved plan"),
									+achieve_plan(Goal,Source,PlanIndex),
									-current_plan(Goal,PlanIndex);
									
//for each not first move, we execute the the next move in the plan 																		
+!achieve_plan(Goal,Source,PlanIndex)[perform]: {B current_plan(Goal,PlanIndex),
												 B next_move(Move), 
												 B remaining_plan(PlanActions),
												 ~B executing_move
												
												 }
									<- 
									print("Achieving plan again"), 
									+!printPlanBeliefs[perform],
									+.lock,
									+!execute_next_move[perform],
									+!achieve_plan(Goal,Source,PlanIndex)[perform],
									-.lock,
									print("Exiting achieving plan");
									
+!execute_next_move[perform]: { B executing_move}
							<-
							do_nothing;

//we just execute the move									
+!execute_next_move[perform]: {B next_move(move_to(Loc)), ~B executing_move}
							<-
							move_to(Loc),
							+executing_move;

//when weve gotten to the location we update our beliefs
+at(Loc) :{True} 
			<- 
			+.lock,
			+!appendPrint("at location ",Loc)[perform],
			+!update_next_move_and_remaining_plan[perform],
			-.lock;
			
			
// in case weve executed the last move			
+!update_next_move_and_remaining_plan[perform] : {B next_move(Move), 
													B remaining_plan([]),
													B executing_move}
													<-
													+.lock,
													+!printPlanBeliefs[perform],
													print("No more moves"),
													-executing_move,
													-next_move(Move),
													-remaining_plan([]),
													-.lock;
//we're in the middle, lets just move on							
+!update_next_move_and_remaining_plan[perform] : {B next_move(Move), 
												B remaining_plan([NextMove|PlanT]),
												B executing_move}
												<-
												+.lock,
												+!printPlanBeliefs[perform],
												
												-next_move(Move),
												-remaining_plan([NextMove|PlanT]),
												+next_move(NextMove),
												+remaining_plan(PlanT),
												+!printPlanBeliefs[perform],
												-executing_move,
												print("removed executing move belief"),
												-.lock;
			

//helper print print function 
//print actions		
+!printPlanBeliefs[perform] : {B next_move(Move), B remaining_plan(Actions)} 
							<- +!printPlanBeliefs(Move,Actions)[perform];
+!printPlanBeliefs(NextMove,RemainingPlan)[perform] : {True} <-
							+.lock,
							+!appendPrint("nextmove ",NextMove)[perform],
							+!appendPrint("remaining ",RemainingPlan)[perform],
							-.lock;
										
+!appendPrint(PString,PVar)[perform] : {True} <- 
							 +.lock,
							 toString(PVar,PVarS),
							 append(PString,PVarS,PrintV),
							print(PrintV),
							-.lock;
							
+!printPlan(Goal,Source,PlanIndex,PlanActions,PlanAnnots)[perform]: {True} <-
	+.lock,
	toString(Goal,PG),
	toString(PlanIndex,PIS),
					toString(PlanActions,PAS),
					toString(PlanAnnots,PAnS),
					toString(Source,SrcS),
					append(" Index ",PIS,P1),
					append(" Actions ",PAS,P2),
					append(" Annotations ",PAnS, P3), 
					append(" Source ", SrcS,P4),
					
					append(P1,P2,PP1),
					append(PP1,P3,PP2),
					append(PG," ",PPG),
					append(PPG,P4,PP4),
					append(PP4,PP2,PP3),
					print(PP3),
					-.lock;						
									
									
									
									